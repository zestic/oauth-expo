{
    "sourceFile": "src/adapters/ExpoPKCEAdapter.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1752837518844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752837533883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n       responseType: AuthSession.ResponseType.Code,\n       codeChallenge: config.codeChallenge,\n       codeChallengeMethod: AuthSession.CodeChallengeMethod.S256,\n       state: config.state,\n-      additionalParameters: config.additionalParameters,\n+      extraParams: config.additionalParameters,\n     });\n   }\n \n   /**\n"
                },
                {
                    "date": 1752837543983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,10 +99,10 @@\n \n   /**\n    * Parse authorization response from callback URL\n    */\n-  parseAuthResponse(url: string): AuthSession.AuthSessionResult {\n-    return AuthSession.AuthSession.parseAuthSessionResultAsync(url, {});\n+  async parseAuthResponse(url: string): Promise<AuthSession.AuthSessionResult> {\n+    return AuthSession.parseAuthSessionResultAsync(url, {});\n   }\n \n   /**\n    * Validate state parameter to prevent CSRF attacks\n"
                },
                {
                    "date": 1752837593604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,14 +14,12 @@\n     codeChallenge: string;\n     codeChallengeMethod: string;\n     codeVerifier: string;\n   }> {\n-    // Generate a random code verifier using the correct API\n-    const codeVerifier = AuthSession.AuthRequest.createRandomCodeChallenge();\n+    // Use a simpler approach with crypto\n+    const codeVerifier = this.generateRandomString(128);\n+    const codeChallenge = await this.sha256(codeVerifier);\n \n-    // Create the code challenge using SHA256\n-    const codeChallenge = AuthSession.AuthRequest.deriveChallenge(codeVerifier);\n-\n     return {\n       codeChallenge,\n       codeChallengeMethod: 'S256',\n       codeVerifier,\n"
                },
                {
                    "date": 1752837610723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,5 +127,31 @@\n       codeVerifier,\n       state,\n     };\n   }\n+\n+  /**\n+   * Generate a random string for code verifier\n+   */\n+  private generateRandomString(length: number): string {\n+    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n+    let result = '';\n+    for (let i = 0; i < length; i++) {\n+      result += charset.charAt(Math.floor(Math.random() * charset.length));\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Generate SHA256 hash for code challenge\n+   */\n+  private async sha256(plain: string): Promise<string> {\n+    const encoder = new TextEncoder();\n+    const data = encoder.encode(plain);\n+    const hash = await Crypto.digestStringAsync(\n+      Crypto.CryptoDigestAlgorithm.SHA256,\n+      plain,\n+      { encoding: Crypto.CryptoEncoding.BASE64URL }\n+    );\n+    return hash;\n+  }\n }\n"
                },
                {
                    "date": 1752837719779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,10 +97,20 @@\n \n   /**\n    * Parse authorization response from callback URL\n    */\n-  async parseAuthResponse(url: string): Promise<AuthSession.AuthSessionResult> {\n-    return AuthSession.parseAuthSessionResultAsync(url, {});\n+  parseAuthResponse(url: string): { type: string; params: Record<string, string> } {\n+    // Simple URL parsing for demo purposes\n+    const urlObj = new URL(url);\n+    const params: Record<string, string> = {};\n+    urlObj.searchParams.forEach((value, key) => {\n+      params[key] = value;\n+    });\n+\n+    return {\n+      type: params.error ? 'error' : 'success',\n+      params,\n+    };\n   }\n \n   /**\n    * Validate state parameter to prevent CSRF attacks\n"
                },
                {
                    "date": 1752837731484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,14 +154,13 @@\n   /**\n    * Generate SHA256 hash for code challenge\n    */\n   private async sha256(plain: string): Promise<string> {\n-    const encoder = new TextEncoder();\n-    const data = encoder.encode(plain);\n     const hash = await Crypto.digestStringAsync(\n       Crypto.CryptoDigestAlgorithm.SHA256,\n       plain,\n-      { encoding: Crypto.CryptoEncoding.BASE64URL }\n+      { encoding: Crypto.CryptoEncoding.BASE64 }\n     );\n-    return hash;\n+    // Convert base64 to base64url\n+    return hash.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n   }\n }\n"
                },
                {
                    "date": 1752839353080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n-import * as AuthSession from 'expo-auth-session';\n import * as Crypto from 'expo-crypto';\n-import type { PKCEAdapter } from '../types';\n+import type { PKCEAdapter, PKCEChallenge } from '@zestic/oauth-core';\n \n /**\n  * Expo PKCE adapter using expo-auth-session\n  * Provides PKCE code challenge generation and state management\n"
                },
                {
                    "date": 1752839367470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,13 +8,9 @@\n export class ExpoPKCEAdapter implements PKCEAdapter {\n   /**\n    * Generate PKCE code challenge, method, and verifier\n    */\n-  async generateCodeChallenge(): Promise<{\n-    codeChallenge: string;\n-    codeChallengeMethod: string;\n-    codeVerifier: string;\n-  }> {\n+  async generateCodeChallenge(): Promise<PKCEChallenge> {\n     // Use a simpler approach with crypto\n     const codeVerifier = this.generateRandomString(128);\n     const codeChallenge = await this.sha256(codeVerifier);\n \n@@ -27,9 +23,9 @@\n \n   /**\n    * Generate a random state parameter for CSRF protection\n    */\n-  generateState(): string {\n+  async generateState(): Promise<string> {\n     return Crypto.randomUUID();\n   }\n \n   /**\n"
                },
                {
                    "date": 1752839388038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,115 +27,11 @@\n   async generateState(): Promise<string> {\n     return Crypto.randomUUID();\n   }\n \n-  /**\n-   * Create a complete AuthRequest for OAuth authorization\n-   */\n-  createAuthRequest(config: {\n-    clientId: string;\n-    scopes: string[];\n-    redirectUri: string;\n-    codeChallenge: string;\n-    codeChallengeMethod: string;\n-    state: string;\n-    additionalParameters?: Record<string, string>;\n-  }): AuthSession.AuthRequest {\n-    return new AuthSession.AuthRequest({\n-      clientId: config.clientId,\n-      scopes: config.scopes,\n-      redirectUri: config.redirectUri,\n-      responseType: AuthSession.ResponseType.Code,\n-      codeChallenge: config.codeChallenge,\n-      codeChallengeMethod: AuthSession.CodeChallengeMethod.S256,\n-      state: config.state,\n-      extraParams: config.additionalParameters,\n-    });\n-  }\n \n-  /**\n-   * Generate authorization URL for OAuth flow\n-   */\n-  async generateAuthorizationUrl(config: {\n-    authorizationEndpoint: string;\n-    clientId: string;\n-    scopes: string[];\n-    redirectUri: string;\n-    additionalParameters?: Record<string, string>;\n-  }): Promise<{\n-    authUrl: string;\n-    codeVerifier: string;\n-    state: string;\n-  }> {\n-    const { codeChallenge, codeChallengeMethod, codeVerifier } = await this.generateCodeChallenge();\n-    const state = this.generateState();\n \n-    const authRequest = this.createAuthRequest({\n-      clientId: config.clientId,\n-      scopes: config.scopes,\n-      redirectUri: config.redirectUri,\n-      codeChallenge,\n-      codeChallengeMethod,\n-      state,\n-      additionalParameters: config.additionalParameters,\n-    });\n-\n-    const authUrl = authRequest.makeAuthUrlAsync({\n-      authorizationEndpoint: config.authorizationEndpoint,\n-    });\n-\n-    return {\n-      authUrl: await authUrl,\n-      codeVerifier,\n-      state,\n-    };\n-  }\n-\n   /**\n-   * Parse authorization response from callback URL\n-   */\n-  parseAuthResponse(url: string): { type: string; params: Record<string, string> } {\n-    // Simple URL parsing for demo purposes\n-    const urlObj = new URL(url);\n-    const params: Record<string, string> = {};\n-    urlObj.searchParams.forEach((value, key) => {\n-      params[key] = value;\n-    });\n-\n-    return {\n-      type: params.error ? 'error' : 'success',\n-      params,\n-    };\n-  }\n-\n-  /**\n-   * Validate state parameter to prevent CSRF attacks\n-   */\n-  validateState(receivedState: string, expectedState: string): boolean {\n-    return receivedState === expectedState;\n-  }\n-\n-  /**\n-   * Generate parameters for magic link authentication\n-   */\n-  async generateMagicLinkParams(): Promise<{\n-    codeChallenge: string;\n-    codeChallengeMethod: string;\n-    codeVerifier: string;\n-    state: string;\n-  }> {\n-    const { codeChallenge, codeChallengeMethod, codeVerifier } = await this.generateCodeChallenge();\n-    const state = this.generateState();\n-\n-    return {\n-      codeChallenge,\n-      codeChallengeMethod,\n-      codeVerifier,\n-      state,\n-    };\n-  }\n-\n-  /**\n    * Generate a random string for code verifier\n    */\n   private generateRandomString(length: number): string {\n     const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n"
                },
                {
                    "date": 1752839445869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n \n   /**\n    * Generate a random state parameter for CSRF protection\n    */\n-  async generateState(): Promise<string> {\n+  generateState(): string {\n     return Crypto.randomUUID();\n   }\n \n \n"
                },
                {
                    "date": 1752840073135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,17 +1,16 @@\n import * as Crypto from 'expo-crypto';\n import type { PKCEAdapter, PKCEChallenge } from '@zestic/oauth-core';\n \n /**\n- * Expo PKCE adapter using expo-auth-session\n+ * Expo PKCE adapter using expo-crypto\n  * Provides PKCE code challenge generation and state management\n  */\n export class ExpoPKCEAdapter implements PKCEAdapter {\n   /**\n    * Generate PKCE code challenge, method, and verifier\n    */\n   async generateCodeChallenge(): Promise<PKCEChallenge> {\n-    // Use a simpler approach with crypto\n     const codeVerifier = this.generateRandomString(128);\n     const codeChallenge = await this.sha256(codeVerifier);\n \n     return {\n"
                },
                {
                    "date": 1752840489983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n \n   /**\n    * Generate a random state parameter for CSRF protection\n    */\n-  generateState(): string {\n+  async generateState(): Promise<string> {\n     return Crypto.randomUUID();\n   }\n \n \n"
                }
            ],
            "date": 1752837518844,
            "name": "Commit-0",
            "content": "import * as AuthSession from 'expo-auth-session';\nimport * as Crypto from 'expo-crypto';\nimport type { PKCEAdapter } from '../types';\n\n/**\n * Expo PKCE adapter using expo-auth-session\n * Provides PKCE code challenge generation and state management\n */\nexport class ExpoPKCEAdapter implements PKCEAdapter {\n  /**\n   * Generate PKCE code challenge, method, and verifier\n   */\n  async generateCodeChallenge(): Promise<{\n    codeChallenge: string;\n    codeChallengeMethod: string;\n    codeVerifier: string;\n  }> {\n    // Generate a random code verifier using the correct API\n    const codeVerifier = AuthSession.AuthRequest.createRandomCodeChallenge();\n\n    // Create the code challenge using SHA256\n    const codeChallenge = AuthSession.AuthRequest.deriveChallenge(codeVerifier);\n\n    return {\n      codeChallenge,\n      codeChallengeMethod: 'S256',\n      codeVerifier,\n    };\n  }\n\n  /**\n   * Generate a random state parameter for CSRF protection\n   */\n  generateState(): string {\n    return Crypto.randomUUID();\n  }\n\n  /**\n   * Create a complete AuthRequest for OAuth authorization\n   */\n  createAuthRequest(config: {\n    clientId: string;\n    scopes: string[];\n    redirectUri: string;\n    codeChallenge: string;\n    codeChallengeMethod: string;\n    state: string;\n    additionalParameters?: Record<string, string>;\n  }): AuthSession.AuthRequest {\n    return new AuthSession.AuthRequest({\n      clientId: config.clientId,\n      scopes: config.scopes,\n      redirectUri: config.redirectUri,\n      responseType: AuthSession.ResponseType.Code,\n      codeChallenge: config.codeChallenge,\n      codeChallengeMethod: AuthSession.CodeChallengeMethod.S256,\n      state: config.state,\n      additionalParameters: config.additionalParameters,\n    });\n  }\n\n  /**\n   * Generate authorization URL for OAuth flow\n   */\n  async generateAuthorizationUrl(config: {\n    authorizationEndpoint: string;\n    clientId: string;\n    scopes: string[];\n    redirectUri: string;\n    additionalParameters?: Record<string, string>;\n  }): Promise<{\n    authUrl: string;\n    codeVerifier: string;\n    state: string;\n  }> {\n    const { codeChallenge, codeChallengeMethod, codeVerifier } = await this.generateCodeChallenge();\n    const state = this.generateState();\n\n    const authRequest = this.createAuthRequest({\n      clientId: config.clientId,\n      scopes: config.scopes,\n      redirectUri: config.redirectUri,\n      codeChallenge,\n      codeChallengeMethod,\n      state,\n      additionalParameters: config.additionalParameters,\n    });\n\n    const authUrl = authRequest.makeAuthUrlAsync({\n      authorizationEndpoint: config.authorizationEndpoint,\n    });\n\n    return {\n      authUrl: await authUrl,\n      codeVerifier,\n      state,\n    };\n  }\n\n  /**\n   * Parse authorization response from callback URL\n   */\n  parseAuthResponse(url: string): AuthSession.AuthSessionResult {\n    return AuthSession.AuthSession.parseAuthSessionResultAsync(url, {});\n  }\n\n  /**\n   * Validate state parameter to prevent CSRF attacks\n   */\n  validateState(receivedState: string, expectedState: string): boolean {\n    return receivedState === expectedState;\n  }\n\n  /**\n   * Generate parameters for magic link authentication\n   */\n  async generateMagicLinkParams(): Promise<{\n    codeChallenge: string;\n    codeChallengeMethod: string;\n    codeVerifier: string;\n    state: string;\n  }> {\n    const { codeChallenge, codeChallengeMethod, codeVerifier } = await this.generateCodeChallenge();\n    const state = this.generateState();\n\n    return {\n      codeChallenge,\n      codeChallengeMethod,\n      codeVerifier,\n      state,\n    };\n  }\n}\n"
        }
    ]
}