{
    "sourceFile": "src/ExpoOAuthAdapter.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1752918007463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752918332128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,15 +62,11 @@\n    * Generate PKCE parameters for OAuth flow\n    * @deprecated Use generateAuthorizationUrl instead which handles PKCE internally\n    */\n   async generatePKCEParams(): Promise<PKCEParams> {\n-    const challenge = await this.pkceAdapter.generateCodeChallenge();\n-    const state = await this.pkceAdapter.generateState();\n+    const challenge = await this.oauthCore.generatePKCEChallenge();\n+    const state = await this.oauthCore.generateState();\n \n-    // Store PKCE parameters for later verification\n-    await this.storageAdapter.setItem('oauth_code_verifier', challenge.codeVerifier);\n-    await this.storageAdapter.setItem('oauth_state', state);\n-\n     return {\n       codeChallenge: challenge.codeChallenge,\n       codeChallengeMethod: challenge.codeChallengeMethod,\n       codeVerifier: challenge.codeVerifier,\n"
                },
                {
                    "date": 1752931704164,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,139 @@\n+import { OAuthCore } from '@zestic/oauth-core';\n+import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from './adapters';\n+import type { \n+  ExpoOAuthConfig, \n+  OAuthCallbackParams, \n+  OAuthResult, \n+  PKCEParams,\n+  TokenData,\n+  OAuthAdapters \n+} from './types';\n+\n+/**\n+ * Expo-specific OAuth adapter that integrates with oauth-core\n+ */\n+export class ExpoOAuthAdapter {\n+  private oauthCore: OAuthCore;\n+  private storageAdapter: ExpoStorageAdapter;\n+  private httpAdapter: ExpoHttpAdapter;\n+  private pkceAdapter: ExpoPKCEAdapter;\n+\n+  constructor(private config: ExpoOAuthConfig) {\n+    // Initialize adapters\n+    this.storageAdapter = new ExpoStorageAdapter();\n+    this.httpAdapter = new ExpoHttpAdapter();\n+    this.pkceAdapter = new ExpoPKCEAdapter();\n+\n+    const adapters: OAuthAdapters = {\n+      storage: this.storageAdapter,\n+      http: this.httpAdapter,\n+      pkce: this.pkceAdapter,\n+    };\n+\n+    // Initialize OAuth core with config and adapters\n+    this.oauthCore = new OAuthCore(config, adapters, config.flows);\n+  }\n+\n+  /**\n+   * Handle OAuth callback parameters\n+   */\n+  async handleCallback(params: OAuthCallbackParams): Promise<OAuthResult> {\n+    // Convert params to URLSearchParams, filtering out null/undefined values\n+    const urlParams = new URLSearchParams();\n+    \n+    Object.entries(params).forEach(([key, value]) => {\n+      if (value !== null && value !== undefined) {\n+        urlParams.set(key, String(value));\n+      }\n+    });\n+\n+    return this.oauthCore.handleCallback(urlParams);\n+  }\n+\n+  /**\n+   * Generate authorization URL with PKCE parameters\n+   * This method generates PKCE parameters internally and stores them for later use\n+   */\n+  async generateAuthorizationUrl(additionalParams?: Record<string, string>): Promise<{ url: string; state: string }> {\n+    return this.oauthCore.generateAuthorizationUrl(additionalParams);\n+  }\n+\n+  /**\n+   * Generate PKCE parameters for OAuth flow\n+   * @deprecated Use generateAuthorizationUrl instead which handles PKCE internally\n+   */\n+  async generatePKCEParams(): Promise<PKCEParams> {\n+    const challenge = await this.oauthCore.generatePKCEChallenge();\n+    const state = await this.oauthCore.generateState();\n+\n+    return {\n+      codeChallenge: challenge.codeChallenge,\n+      codeChallengeMethod: challenge.codeChallengeMethod,\n+      codeVerifier: challenge.codeVerifier,\n+      state,\n+    };\n+  }\n+\n+  /**\n+   * Check if user is currently authenticated\n+   */\n+  async isAuthenticated(): Promise<boolean> {\n+    try {\n+      const accessToken = await this.oauthCore.getAccessToken();\n+      if (!accessToken) {\n+        return false;\n+      }\n+\n+      const isExpired = await this.oauthCore.isTokenExpired();\n+      return !isExpired;\n+    } catch (error) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Get current access token if valid\n+   */\n+  async getAccessToken(): Promise<string | null> {\n+    try {\n+      const tokens = await this.storageAdapter.getTokens();\n+      \n+      if (!tokens.accessToken) {\n+        return null;\n+      }\n+\n+      const isExpired = await this.storageAdapter.isTokenExpired(tokens.expiresAt);\n+      \n+      if (isExpired) {\n+        // Clear expired tokens\n+        await this.logout();\n+        return null;\n+      }\n+\n+      return tokens.accessToken;\n+    } catch (error) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get current tokens\n+   */\n+  async getTokens(): Promise<TokenData> {\n+    return this.storageAdapter.getTokens();\n+  }\n+\n+  /**\n+   * Clear all OAuth-related storage\n+   */\n+  async logout(): Promise<void> {\n+    await this.storageAdapter.clearOAuthStorage();\n+  }\n+\n+  /**\n+   * Get the OAuth configuration\n+   */\n+  getConfig(): ExpoOAuthConfig {\n+    return this.config;\n+  }\n+}\n"
                },
                {
                    "date": 1752931729512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,163 +95,23 @@\n    * Get current access token if valid\n    */\n   async getAccessToken(): Promise<string | null> {\n     try {\n-      const tokens = await this.storageAdapter.getTokens();\n-      \n-      if (!tokens.accessToken) {\n-        return null;\n-      }\n+      const accessToken = await this.oauthCore.getAccessToken();\n \n-      const isExpired = await this.storageAdapter.isTokenExpired(tokens.expiresAt);\n-      \n-      if (isExpired) {\n-        // Clear expired tokens\n-        await this.logout();\n+      if (!accessToken) {\n         return null;\n       }\n \n-      return tokens.accessToken;\n-    } catch (error) {\n-      return null;\n-    }\n-  }\n+      const isExpired = await this.oauthCore.isTokenExpired();\n \n-  /**\n-   * Get current tokens\n-   */\n-  async getTokens(): Promise<TokenData> {\n-    return this.storageAdapter.getTokens();\n-  }\n-\n-  /**\n-   * Clear all OAuth-related storage\n-   */\n-  async logout(): Promise<void> {\n-    await this.storageAdapter.clearOAuthStorage();\n-  }\n-\n-  /**\n-   * Get the OAuth configuration\n-   */\n-  getConfig(): ExpoOAuthConfig {\n-    return this.config;\n-  }\n-}\n-import { OAuthCore } from '@zestic/oauth-core';\n-import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from './adapters';\n-import type { \n-  ExpoOAuthConfig, \n-  OAuthCallbackParams, \n-  OAuthResult, \n-  PKCEParams,\n-  TokenData,\n-  OAuthAdapters \n-} from './types';\n-\n-/**\n- * Expo-specific OAuth adapter that integrates with oauth-core\n- */\n-export class ExpoOAuthAdapter {\n-  private oauthCore: OAuthCore;\n-  private storageAdapter: ExpoStorageAdapter;\n-  private httpAdapter: ExpoHttpAdapter;\n-  private pkceAdapter: ExpoPKCEAdapter;\n-\n-  constructor(private config: ExpoOAuthConfig) {\n-    // Initialize adapters\n-    this.storageAdapter = new ExpoStorageAdapter();\n-    this.httpAdapter = new ExpoHttpAdapter();\n-    this.pkceAdapter = new ExpoPKCEAdapter();\n-\n-    const adapters: OAuthAdapters = {\n-      storage: this.storageAdapter,\n-      http: this.httpAdapter,\n-      pkce: this.pkceAdapter,\n-    };\n-\n-    // Initialize OAuth core with config and adapters\n-    this.oauthCore = new OAuthCore(config, adapters, config.flows);\n-  }\n-\n-  /**\n-   * Handle OAuth callback parameters\n-   */\n-  async handleCallback(params: OAuthCallbackParams): Promise<OAuthResult> {\n-    // Convert params to URLSearchParams, filtering out null/undefined values\n-    const urlParams = new URLSearchParams();\n-    \n-    Object.entries(params).forEach(([key, value]) => {\n-      if (value !== null && value !== undefined) {\n-        urlParams.set(key, String(value));\n-      }\n-    });\n-\n-    return this.oauthCore.handleCallback(urlParams);\n-  }\n-\n-  /**\n-   * Generate authorization URL with PKCE parameters\n-   * This method generates PKCE parameters internally and stores them for later use\n-   */\n-  async generateAuthorizationUrl(additionalParams?: Record<string, string>): Promise<{ url: string; state: string }> {\n-    return this.oauthCore.generateAuthorizationUrl(additionalParams);\n-  }\n-\n-  /**\n-   * Generate PKCE parameters for OAuth flow\n-   * @deprecated Use generateAuthorizationUrl instead which handles PKCE internally\n-   */\n-  async generatePKCEParams(): Promise<PKCEParams> {\n-    const challenge = await this.oauthCore.generatePKCEChallenge();\n-    const state = await this.oauthCore.generateState();\n-\n-    return {\n-      codeChallenge: challenge.codeChallenge,\n-      codeChallengeMethod: challenge.codeChallengeMethod,\n-      codeVerifier: challenge.codeVerifier,\n-      state,\n-    };\n-  }\n-\n-  /**\n-   * Check if user is currently authenticated\n-   */\n-  async isAuthenticated(): Promise<boolean> {\n-    try {\n-      const tokens = await this.storageAdapter.getTokens();\n-      \n-      if (!tokens.accessToken) {\n-        return false;\n-      }\n-\n-      const isExpired = await this.storageAdapter.isTokenExpired(tokens.expiresAt);\n-      return !isExpired;\n-    } catch (error) {\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * Get current access token if valid\n-   */\n-  async getAccessToken(): Promise<string | null> {\n-    try {\n-      const tokens = await this.storageAdapter.getTokens();\n-      \n-      if (!tokens.accessToken) {\n-        return null;\n-      }\n-\n-      const isExpired = await this.storageAdapter.isTokenExpired(tokens.expiresAt);\n-      \n       if (isExpired) {\n         // Clear expired tokens\n         await this.logout();\n         return null;\n       }\n \n-      return tokens.accessToken;\n+      return accessToken;\n     } catch (error) {\n       return null;\n     }\n   }\n"
                },
                {
                    "date": 1753027105823,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,17 @@\n import { OAuthCore } from '@zestic/oauth-core';\n-import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from './adapters';\n-import type { \n-  ExpoOAuthConfig, \n-  OAuthCallbackParams, \n-  OAuthResult, \n+import {\n+  ExpoStorageAdapter,\n+  ExpoHttpAdapter,\n+  ExpoPKCEAdapter,\n+} from './adapters';\n+import type {\n+  ExpoOAuthConfig,\n+  OAuthCallbackParams,\n+  OAuthResult,\n   PKCEParams,\n   TokenData,\n-  OAuthAdapters \n+  OAuthAdapters,\n } from './types';\n \n /**\n  * Expo-specific OAuth adapter that integrates with oauth-core\n@@ -30,18 +34,20 @@\n       pkce: this.pkceAdapter,\n     };\n \n     // Initialize OAuth core with config and adapters\n-    this.oauthCore = new OAuthCore(config, adapters, config.flows);\n+    // Default to authorization_code flow if no flows specified\n+    const flows = (config as any).flows || ['authorization_code'];\n+    this.oauthCore = new OAuthCore(config, adapters, flows);\n   }\n \n   /**\n    * Handle OAuth callback parameters\n    */\n   async handleCallback(params: OAuthCallbackParams): Promise<OAuthResult> {\n     // Convert params to URLSearchParams, filtering out null/undefined values\n     const urlParams = new URLSearchParams();\n-    \n+\n     Object.entries(params).forEach(([key, value]) => {\n       if (value !== null && value !== undefined) {\n         urlParams.set(key, String(value));\n       }\n@@ -53,9 +59,11 @@\n   /**\n    * Generate authorization URL with PKCE parameters\n    * This method generates PKCE parameters internally and stores them for later use\n    */\n-  async generateAuthorizationUrl(additionalParams?: Record<string, string>): Promise<{ url: string; state: string }> {\n+  async generateAuthorizationUrl(\n+    additionalParams?: Record<string, string>\n+  ): Promise<{ url: string; state: string }> {\n     return this.oauthCore.generateAuthorizationUrl(additionalParams);\n   }\n \n   /**\n"
                }
            ],
            "date": 1752918007462,
            "name": "Commit-0",
            "content": "import { OAuthCore } from '@zestic/oauth-core';\nimport { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from './adapters';\nimport type { \n  ExpoOAuthConfig, \n  OAuthCallbackParams, \n  OAuthResult, \n  PKCEParams,\n  TokenData,\n  OAuthAdapters \n} from './types';\n\n/**\n * Expo-specific OAuth adapter that integrates with oauth-core\n */\nexport class ExpoOAuthAdapter {\n  private oauthCore: OAuthCore;\n  private storageAdapter: ExpoStorageAdapter;\n  private httpAdapter: ExpoHttpAdapter;\n  private pkceAdapter: ExpoPKCEAdapter;\n\n  constructor(private config: ExpoOAuthConfig) {\n    // Initialize adapters\n    this.storageAdapter = new ExpoStorageAdapter();\n    this.httpAdapter = new ExpoHttpAdapter();\n    this.pkceAdapter = new ExpoPKCEAdapter();\n\n    const adapters: OAuthAdapters = {\n      storage: this.storageAdapter,\n      http: this.httpAdapter,\n      pkce: this.pkceAdapter,\n    };\n\n    // Initialize OAuth core with config and adapters\n    this.oauthCore = new OAuthCore(config, adapters, config.flows);\n  }\n\n  /**\n   * Handle OAuth callback parameters\n   */\n  async handleCallback(params: OAuthCallbackParams): Promise<OAuthResult> {\n    // Convert params to URLSearchParams, filtering out null/undefined values\n    const urlParams = new URLSearchParams();\n    \n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== null && value !== undefined) {\n        urlParams.set(key, String(value));\n      }\n    });\n\n    return this.oauthCore.handleCallback(urlParams);\n  }\n\n  /**\n   * Generate authorization URL with PKCE parameters\n   * This method generates PKCE parameters internally and stores them for later use\n   */\n  async generateAuthorizationUrl(additionalParams?: Record<string, string>): Promise<{ url: string; state: string }> {\n    return this.oauthCore.generateAuthorizationUrl(additionalParams);\n  }\n\n  /**\n   * Generate PKCE parameters for OAuth flow\n   * @deprecated Use generateAuthorizationUrl instead which handles PKCE internally\n   */\n  async generatePKCEParams(): Promise<PKCEParams> {\n    const challenge = await this.pkceAdapter.generateCodeChallenge();\n    const state = await this.pkceAdapter.generateState();\n\n    // Store PKCE parameters for later verification\n    await this.storageAdapter.setItem('oauth_code_verifier', challenge.codeVerifier);\n    await this.storageAdapter.setItem('oauth_state', state);\n\n    return {\n      codeChallenge: challenge.codeChallenge,\n      codeChallengeMethod: challenge.codeChallengeMethod,\n      codeVerifier: challenge.codeVerifier,\n      state,\n    };\n  }\n\n  /**\n   * Check if user is currently authenticated\n   */\n  async isAuthenticated(): Promise<boolean> {\n    try {\n      const tokens = await this.storageAdapter.getTokens();\n      \n      if (!tokens.accessToken) {\n        return false;\n      }\n\n      const isExpired = await this.storageAdapter.isTokenExpired(tokens.expiresAt);\n      return !isExpired;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get current access token if valid\n   */\n  async getAccessToken(): Promise<string | null> {\n    try {\n      const tokens = await this.storageAdapter.getTokens();\n      \n      if (!tokens.accessToken) {\n        return null;\n      }\n\n      const isExpired = await this.storageAdapter.isTokenExpired(tokens.expiresAt);\n      \n      if (isExpired) {\n        // Clear expired tokens\n        await this.logout();\n        return null;\n      }\n\n      return tokens.accessToken;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Get current tokens\n   */\n  async getTokens(): Promise<TokenData> {\n    return this.storageAdapter.getTokens();\n  }\n\n  /**\n   * Clear all OAuth-related storage\n   */\n  async logout(): Promise<void> {\n    await this.storageAdapter.clearOAuthStorage();\n  }\n\n  /**\n   * Get the OAuth configuration\n   */\n  getConfig(): ExpoOAuthConfig {\n    return this.config;\n  }\n}\n"
        }
    ]
}