{
    "sourceFile": "src/__tests__/integration/oauth-flow.test.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1752908137044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752908254892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -224,14 +224,18 @@\n   });\n \n   describe('Error Handling', () => {\n     it('should handle storage errors gracefully', async () => {\n-      // Mock storage error\n-      jest.spyOn(storageAdapter, 'setItem').mockRejectedValueOnce(new Error('Storage full'));\n+      // Mock AsyncStorage directly to trigger the error handling in our adapter\n+      const AsyncStorage = require('@react-native-async-storage/async-storage');\n+      jest.spyOn(AsyncStorage, 'setItem').mockRejectedValueOnce(new Error('Storage full'));\n \n       await expect(\n         storageAdapter.setItem('test-key', 'test-value')\n       ).rejects.toThrow('Failed to store item with key \"test-key\": Error: Storage full');\n+\n+      // Restore the mock\n+      AsyncStorage.setItem.mockRestore();\n     });\n \n     it('should handle network errors gracefully', async () => {\n       (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n"
                },
                {
                    "date": 1752908309506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -282,21 +282,16 @@\n         callback('application/json', 'content-type');\n       });\n       (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n \n-      // 3. Handle callback (this would normally be done by OAuthCore)\n-      // For integration test, we'll just verify the parameters are correct\n-      expect(callbackParams.code).toBe('authorization-code-123');\n-      expect(callbackParams.state).toBe(pkceParams.state);\n+      // 3. Handle callback using the adapter (this will use OAuthCore internally)\n+      const result = await adapter.handleCallback(callbackParams);\n \n-      // 4. Verify authentication state\n-      // In a real scenario, tokens would be stored after successful callback\n-      await storageAdapter.storeTokens({\n-        accessToken: 'access-token-123',\n-        refreshToken: 'refresh-token-456',\n-        expiresIn: 3600,\n-      });\n+      // 4. Verify the callback was successful\n+      expect(result.success).toBe(true);\n+      expect(result.accessToken).toBe('access-token-123');\n \n+      // 5. Verify authentication state\n       expect(await adapter.isAuthenticated()).toBe(true);\n       expect(await adapter.getAccessToken()).toBe('access-token-123');\n     });\n   });\n"
                },
                {
                    "date": 1752917258643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -255,17 +255,17 @@\n   });\n \n   describe('Real-world Scenarios', () => {\n     it('should handle complete authorization code flow', async () => {\n-      // 1. Generate PKCE parameters\n-      const pkceParams = await adapter.generatePKCEParams();\n-      expect(pkceParams).toHaveProperty('codeChallenge');\n-      expect(pkceParams).toHaveProperty('state');\n+      // 1. Generate authorization URL (this stores PKCE params internally)\n+      const authResult = await adapter.generateAuthorizationUrl();\n+      expect(authResult.url).toBeTruthy();\n+      expect(authResult.state).toBeTruthy();\n \n       // 2. Simulate callback with authorization code\n       const callbackParams = {\n         code: 'authorization-code-123',\n-        state: pkceParams.state,\n+        state: authResult.state,\n       };\n \n       // Mock token exchange response\n       const mockTokenResponse = {\n"
                },
                {
                    "date": 1752918268545,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,298 @@\n+import { ExpoOAuthAdapter } from '../../ExpoOAuthAdapter';\n+import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../../adapters';\n+import type { ExpoOAuthConfig } from '../../types';\n+\n+// Integration tests that test the full OAuth flow without mocking internal components\n+describe('OAuth Flow Integration Tests', () => {\n+  let adapter: ExpoOAuthAdapter;\n+  let storageAdapter: ExpoStorageAdapter;\n+  let httpAdapter: ExpoHttpAdapter;\n+  let pkceAdapter: ExpoPKCEAdapter;\n+\n+  const mockConfig: ExpoOAuthConfig = {\n+    clientId: 'test-client-id',\n+    endpoints: {\n+      authorization: 'https://auth.example.com/authorize',\n+      token: 'https://auth.example.com/token',\n+    },\n+    redirectUri: 'myapp://oauth/callback',\n+    scopes: ['read', 'write'],\n+  };\n+\n+  beforeEach(() => {\n+    // Clear mock storage between tests\n+    (global as any).clearMockStorage?.();\n+\n+    // Use real adapter instances for integration testing\n+    storageAdapter = new ExpoStorageAdapter();\n+    httpAdapter = new ExpoHttpAdapter();\n+    pkceAdapter = new ExpoPKCEAdapter();\n+    adapter = new ExpoOAuthAdapter(mockConfig);\n+  });\n+\n+  describe('PKCE Parameter Generation', () => {\n+    it('should generate valid PKCE parameters', async () => {\n+      const params = await adapter.generatePKCEParams();\n+\n+      expect(params).toHaveProperty('codeChallenge');\n+      expect(params).toHaveProperty('codeChallengeMethod', 'S256');\n+      expect(params).toHaveProperty('codeVerifier');\n+      expect(params).toHaveProperty('state');\n+\n+      // Verify code verifier format (128 characters, unreserved chars only)\n+      expect(params.codeVerifier).toHaveLength(128);\n+      expect(params.codeVerifier).toMatch(/^[A-Za-z0-9\\-\\._~]+$/);\n+\n+      // Verify code challenge is base64url encoded\n+      expect(params.codeChallenge).toMatch(/^[A-Za-z0-9\\-_]+$/);\n+      expect(params.codeChallenge).not.toContain('=');\n+      expect(params.codeChallenge).not.toContain('+');\n+      expect(params.codeChallenge).not.toContain('/');\n+\n+      // Verify state is a UUID\n+      expect(params.state).toMatch(\n+        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n+      );\n+    });\n+\n+    it('should generate different parameters on each call', async () => {\n+      const params1 = await adapter.generatePKCEParams();\n+      const params2 = await adapter.generatePKCEParams();\n+\n+      expect(params1.codeVerifier).not.toBe(params2.codeVerifier);\n+      expect(params1.codeChallenge).not.toBe(params2.codeChallenge);\n+      expect(params1.state).not.toBe(params2.state);\n+    });\n+  });\n+\n+  describe('Storage Integration', () => {\n+    it('should store and retrieve tokens correctly', async () => {\n+      const tokens = {\n+        accessToken: 'access-token-123',\n+        refreshToken: 'refresh-token-456',\n+        expiresIn: 3600,\n+      };\n+\n+      await storageAdapter.storeTokens(tokens);\n+\n+      const retrievedTokens = await storageAdapter.getTokens();\n+      expect(retrievedTokens.accessToken).toBe('access-token-123');\n+      expect(retrievedTokens.refreshToken).toBe('refresh-token-456');\n+      expect(retrievedTokens.expiresAt).toBeGreaterThan(Date.now());\n+    });\n+\n+    it('should handle token expiration correctly', async () => {\n+      // Store expired token\n+      const expiredTime = Date.now() - 1000;\n+      await storageAdapter.storeTokens({\n+        accessToken: 'expired-token',\n+        expiresIn: -1, // Already expired\n+      });\n+\n+      const isExpired = await storageAdapter.isTokenExpired();\n+      expect(isExpired).toBe(true);\n+    });\n+\n+    it('should clear all OAuth storage', async () => {\n+      // Store some data\n+      await storageAdapter.storeTokens({\n+        accessToken: 'token-123',\n+        refreshToken: 'refresh-456',\n+      });\n+      await storageAdapter.setItem('oauth_state', 'state-789');\n+      await storageAdapter.setItem('oauth_code_verifier', 'verifier-abc');\n+\n+      // Clear OAuth storage\n+      await storageAdapter.clearOAuthStorage();\n+\n+      // Verify all OAuth data is cleared\n+      const tokens = await storageAdapter.getTokens();\n+      expect(tokens.accessToken).toBeNull();\n+      expect(tokens.refreshToken).toBeNull();\n+      expect(tokens.expiresAt).toBeNull();\n+\n+      const state = await storageAdapter.getItem('oauth_state');\n+      const verifier = await storageAdapter.getItem('oauth_code_verifier');\n+      expect(state).toBeNull();\n+      expect(verifier).toBeNull();\n+    });\n+  });\n+\n+  describe('HTTP Adapter Integration', () => {\n+    it('should make POST requests with JSON data', async () => {\n+      // Mock successful response\n+      const mockResponse = {\n+        ok: true,\n+        status: 200,\n+        headers: new Map([['content-type', 'application/json']]),\n+        json: () => Promise.resolve({ access_token: 'token-123' }),\n+      };\n+      mockResponse.headers.forEach = jest.fn((callback) => {\n+        callback('application/json', 'content-type');\n+      });\n+      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n+\n+      const result = await httpAdapter.post('https://api.example.com/token', {\n+        grant_type: 'authorization_code',\n+        code: 'auth-code',\n+      });\n+\n+      expect(result.status).toBe(200);\n+      expect(result.data).toEqual({ access_token: 'token-123' });\n+      expect(global.fetch).toHaveBeenCalledWith(\n+        'https://api.example.com/token',\n+        expect.objectContaining({\n+          method: 'POST',\n+          headers: expect.objectContaining({\n+            'Content-Type': 'application/json',\n+          }),\n+          body: JSON.stringify({\n+            grant_type: 'authorization_code',\n+            code: 'auth-code',\n+          }),\n+        })\n+      );\n+    });\n+\n+    it('should make GET requests correctly', async () => {\n+      const mockResponse = {\n+        ok: true,\n+        status: 200,\n+        headers: new Map([['content-type', 'application/json']]),\n+        json: () => Promise.resolve({ user: 'john' }),\n+      };\n+      mockResponse.headers.forEach = jest.fn((callback) => {\n+        callback('application/json', 'content-type');\n+      });\n+      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n+\n+      const result = await httpAdapter.get('https://api.example.com/user', {\n+        Authorization: 'Bearer token-123',\n+      });\n+\n+      expect(result.status).toBe(200);\n+      expect(result.data).toEqual({ user: 'john' });\n+      expect(global.fetch).toHaveBeenCalledWith(\n+        'https://api.example.com/user',\n+        expect.objectContaining({\n+          method: 'GET',\n+          headers: expect.objectContaining({\n+            Authorization: 'Bearer token-123',\n+          }),\n+        })\n+      );\n+    });\n+  });\n+\n+  describe('Authentication State Management', () => {\n+    it('should correctly determine authentication status', async () => {\n+      // Initially not authenticated\n+      expect(await adapter.isAuthenticated()).toBe(false);\n+\n+      // Store valid tokens\n+      await storageAdapter.storeTokens({\n+        accessToken: 'valid-token',\n+        expiresIn: 3600,\n+      });\n+\n+      expect(await adapter.isAuthenticated()).toBe(true);\n+\n+      // Clear tokens\n+      await adapter.logout();\n+\n+      expect(await adapter.isAuthenticated()).toBe(false);\n+    });\n+\n+    it('should handle expired tokens correctly', async () => {\n+      // Store expired token\n+      await storageAdapter.storeTokens({\n+        accessToken: 'expired-token',\n+        expiresIn: -1,\n+      });\n+\n+      // Should not be authenticated with expired token\n+      expect(await adapter.isAuthenticated()).toBe(false);\n+\n+      // Getting access token should clear storage and return null\n+      const token = await adapter.getAccessToken();\n+      expect(token).toBeNull();\n+\n+      // Verify storage was cleared\n+      const tokens = await storageAdapter.getTokens();\n+      expect(tokens.accessToken).toBeNull();\n+    });\n+  });\n+\n+  describe('Error Handling', () => {\n+    it('should handle storage errors gracefully', async () => {\n+      // Mock AsyncStorage directly to trigger the error handling in our adapter\n+      const AsyncStorage = require('@react-native-async-storage/async-storage');\n+      jest.spyOn(AsyncStorage, 'setItem').mockRejectedValueOnce(new Error('Storage full'));\n+\n+      await expect(\n+        storageAdapter.setItem('test-key', 'test-value')\n+      ).rejects.toThrow('Failed to store item with key \"test-key\": Error: Storage full');\n+\n+      // Restore the mock\n+      AsyncStorage.setItem.mockRestore();\n+    });\n+\n+    it('should handle network errors gracefully', async () => {\n+      (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n+\n+      await expect(\n+        httpAdapter.post('https://api.example.com/token', {})\n+      ).rejects.toThrow('Network request failed: Error: Network error');\n+    });\n+\n+    it('should handle PKCE generation errors gracefully', async () => {\n+      // Mock crypto error\n+      const mockCrypto = require('expo-crypto');\n+      mockCrypto.digestStringAsync.mockRejectedValueOnce(new Error('Crypto error'));\n+\n+      await expect(pkceAdapter.generateCodeChallenge()).rejects.toThrow('Crypto error');\n+    });\n+  });\n+\n+  describe('Real-world Scenarios', () => {\n+    it('should handle complete authorization code flow', async () => {\n+      // 1. Generate authorization URL (this stores PKCE params internally)\n+      const authResult = await adapter.generateAuthorizationUrl();\n+      expect(authResult.url).toBeTruthy();\n+      expect(authResult.state).toBeTruthy();\n+\n+      // 2. Simulate callback with authorization code using the same state\n+      const callbackParams = {\n+        code: 'authorization-code-123',\n+        state: authResult.state, // Use the actual state from the authorization URL\n+      };\n+\n+      // Mock token exchange response\n+      const mockTokenResponse = {\n+        ok: true,\n+        status: 200,\n+        headers: new Map([['content-type', 'application/json']]),\n+        json: () => Promise.resolve({\n+          access_token: 'access-token-123',\n+          refresh_token: 'refresh-token-456',\n+          expires_in: 3600,\n+        }),\n+      };\n+      mockTokenResponse.headers.forEach = jest.fn((callback) => {\n+        callback('application/json', 'content-type');\n+      });\n+      (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n+\n+      // 3. Handle callback using the adapter (this will use OAuthCore internally)\n+      const result = await adapter.handleCallback(callbackParams);\n+\n+      // 4. Verify the callback was successful\n+      expect(result.success).toBe(true);\n+      expect(result.accessToken).toBe('access-token-123');\n+\n+      // 5. Verify authentication state\n+      expect(await adapter.isAuthenticated()).toBe(true);\n+      expect(await adapter.getAccessToken()).toBe('access-token-123');\n+    });\n+  });\n+});\n"
                },
                {
                    "date": 1752931532524,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -255,10 +255,13 @@\n   });\n \n   describe('Real-world Scenarios', () => {\n     it('should handle complete authorization code flow', async () => {\n+      // Create a dedicated adapter instance for this test to maintain state\n+      const flowAdapter = new ExpoOAuthAdapter(mockConfig);\n+\n       // 1. Generate authorization URL (this stores PKCE params internally)\n-      const authResult = await adapter.generateAuthorizationUrl();\n+      const authResult = await flowAdapter.generateAuthorizationUrl();\n       expect(authResult.url).toBeTruthy();\n       expect(authResult.state).toBeTruthy();\n \n       // 2. Simulate callback with authorization code using the same state\n@@ -295,302 +298,4 @@\n       expect(await adapter.getAccessToken()).toBe('access-token-123');\n     });\n   });\n });\n-import { ExpoOAuthAdapter } from '../../ExpoOAuthAdapter';\n-import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../../adapters';\n-import type { ExpoOAuthConfig } from '../../types';\n-\n-// Integration tests that test the full OAuth flow without mocking internal components\n-describe('OAuth Flow Integration Tests', () => {\n-  let adapter: ExpoOAuthAdapter;\n-  let storageAdapter: ExpoStorageAdapter;\n-  let httpAdapter: ExpoHttpAdapter;\n-  let pkceAdapter: ExpoPKCEAdapter;\n-\n-  const mockConfig: ExpoOAuthConfig = {\n-    clientId: 'test-client-id',\n-    endpoints: {\n-      authorization: 'https://auth.example.com/authorize',\n-      token: 'https://auth.example.com/token',\n-    },\n-    redirectUri: 'myapp://oauth/callback',\n-    scopes: ['read', 'write'],\n-  };\n-\n-  beforeEach(() => {\n-    // Clear mock storage between tests\n-    (global as any).clearMockStorage?.();\n-\n-    // Use real adapter instances for integration testing\n-    storageAdapter = new ExpoStorageAdapter();\n-    httpAdapter = new ExpoHttpAdapter();\n-    pkceAdapter = new ExpoPKCEAdapter();\n-    adapter = new ExpoOAuthAdapter(mockConfig);\n-  });\n-\n-  describe('PKCE Parameter Generation', () => {\n-    it('should generate valid PKCE parameters', async () => {\n-      const params = await adapter.generatePKCEParams();\n-\n-      expect(params).toHaveProperty('codeChallenge');\n-      expect(params).toHaveProperty('codeChallengeMethod', 'S256');\n-      expect(params).toHaveProperty('codeVerifier');\n-      expect(params).toHaveProperty('state');\n-\n-      // Verify code verifier format (128 characters, unreserved chars only)\n-      expect(params.codeVerifier).toHaveLength(128);\n-      expect(params.codeVerifier).toMatch(/^[A-Za-z0-9\\-\\._~]+$/);\n-\n-      // Verify code challenge is base64url encoded\n-      expect(params.codeChallenge).toMatch(/^[A-Za-z0-9\\-_]+$/);\n-      expect(params.codeChallenge).not.toContain('=');\n-      expect(params.codeChallenge).not.toContain('+');\n-      expect(params.codeChallenge).not.toContain('/');\n-\n-      // Verify state is a UUID\n-      expect(params.state).toMatch(\n-        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n-      );\n-    });\n-\n-    it('should generate different parameters on each call', async () => {\n-      const params1 = await adapter.generatePKCEParams();\n-      const params2 = await adapter.generatePKCEParams();\n-\n-      expect(params1.codeVerifier).not.toBe(params2.codeVerifier);\n-      expect(params1.codeChallenge).not.toBe(params2.codeChallenge);\n-      expect(params1.state).not.toBe(params2.state);\n-    });\n-  });\n-\n-  describe('Storage Integration', () => {\n-    it('should store and retrieve tokens correctly', async () => {\n-      const tokens = {\n-        accessToken: 'access-token-123',\n-        refreshToken: 'refresh-token-456',\n-        expiresIn: 3600,\n-      };\n-\n-      await storageAdapter.storeTokens(tokens);\n-\n-      const retrievedTokens = await storageAdapter.getTokens();\n-      expect(retrievedTokens.accessToken).toBe('access-token-123');\n-      expect(retrievedTokens.refreshToken).toBe('refresh-token-456');\n-      expect(retrievedTokens.expiresAt).toBeGreaterThan(Date.now());\n-    });\n-\n-    it('should handle token expiration correctly', async () => {\n-      // Store expired token\n-      const expiredTime = Date.now() - 1000;\n-      await storageAdapter.storeTokens({\n-        accessToken: 'expired-token',\n-        expiresIn: -1, // Already expired\n-      });\n-\n-      const isExpired = await storageAdapter.isTokenExpired();\n-      expect(isExpired).toBe(true);\n-    });\n-\n-    it('should clear all OAuth storage', async () => {\n-      // Store some data\n-      await storageAdapter.storeTokens({\n-        accessToken: 'token-123',\n-        refreshToken: 'refresh-456',\n-      });\n-      await storageAdapter.setItem('oauth_state', 'state-789');\n-      await storageAdapter.setItem('oauth_code_verifier', 'verifier-abc');\n-\n-      // Clear OAuth storage\n-      await storageAdapter.clearOAuthStorage();\n-\n-      // Verify all OAuth data is cleared\n-      const tokens = await storageAdapter.getTokens();\n-      expect(tokens.accessToken).toBeNull();\n-      expect(tokens.refreshToken).toBeNull();\n-      expect(tokens.expiresAt).toBeNull();\n-\n-      const state = await storageAdapter.getItem('oauth_state');\n-      const verifier = await storageAdapter.getItem('oauth_code_verifier');\n-      expect(state).toBeNull();\n-      expect(verifier).toBeNull();\n-    });\n-  });\n-\n-  describe('HTTP Adapter Integration', () => {\n-    it('should make POST requests with JSON data', async () => {\n-      // Mock successful response\n-      const mockResponse = {\n-        ok: true,\n-        status: 200,\n-        headers: new Map([['content-type', 'application/json']]),\n-        json: () => Promise.resolve({ access_token: 'token-123' }),\n-      };\n-      mockResponse.headers.forEach = jest.fn((callback) => {\n-        callback('application/json', 'content-type');\n-      });\n-      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n-\n-      const result = await httpAdapter.post('https://api.example.com/token', {\n-        grant_type: 'authorization_code',\n-        code: 'auth-code',\n-      });\n-\n-      expect(result.status).toBe(200);\n-      expect(result.data).toEqual({ access_token: 'token-123' });\n-      expect(global.fetch).toHaveBeenCalledWith(\n-        'https://api.example.com/token',\n-        expect.objectContaining({\n-          method: 'POST',\n-          headers: expect.objectContaining({\n-            'Content-Type': 'application/json',\n-          }),\n-          body: JSON.stringify({\n-            grant_type: 'authorization_code',\n-            code: 'auth-code',\n-          }),\n-        })\n-      );\n-    });\n-\n-    it('should make GET requests correctly', async () => {\n-      const mockResponse = {\n-        ok: true,\n-        status: 200,\n-        headers: new Map([['content-type', 'application/json']]),\n-        json: () => Promise.resolve({ user: 'john' }),\n-      };\n-      mockResponse.headers.forEach = jest.fn((callback) => {\n-        callback('application/json', 'content-type');\n-      });\n-      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n-\n-      const result = await httpAdapter.get('https://api.example.com/user', {\n-        Authorization: 'Bearer token-123',\n-      });\n-\n-      expect(result.status).toBe(200);\n-      expect(result.data).toEqual({ user: 'john' });\n-      expect(global.fetch).toHaveBeenCalledWith(\n-        'https://api.example.com/user',\n-        expect.objectContaining({\n-          method: 'GET',\n-          headers: expect.objectContaining({\n-            Authorization: 'Bearer token-123',\n-          }),\n-        })\n-      );\n-    });\n-  });\n-\n-  describe('Authentication State Management', () => {\n-    it('should correctly determine authentication status', async () => {\n-      // Initially not authenticated\n-      expect(await adapter.isAuthenticated()).toBe(false);\n-\n-      // Store valid tokens\n-      await storageAdapter.storeTokens({\n-        accessToken: 'valid-token',\n-        expiresIn: 3600,\n-      });\n-\n-      expect(await adapter.isAuthenticated()).toBe(true);\n-\n-      // Clear tokens\n-      await adapter.logout();\n-\n-      expect(await adapter.isAuthenticated()).toBe(false);\n-    });\n-\n-    it('should handle expired tokens correctly', async () => {\n-      // Store expired token\n-      await storageAdapter.storeTokens({\n-        accessToken: 'expired-token',\n-        expiresIn: -1,\n-      });\n-\n-      // Should not be authenticated with expired token\n-      expect(await adapter.isAuthenticated()).toBe(false);\n-\n-      // Getting access token should clear storage and return null\n-      const token = await adapter.getAccessToken();\n-      expect(token).toBeNull();\n-\n-      // Verify storage was cleared\n-      const tokens = await storageAdapter.getTokens();\n-      expect(tokens.accessToken).toBeNull();\n-    });\n-  });\n-\n-  describe('Error Handling', () => {\n-    it('should handle storage errors gracefully', async () => {\n-      // Mock AsyncStorage directly to trigger the error handling in our adapter\n-      const AsyncStorage = require('@react-native-async-storage/async-storage');\n-      jest.spyOn(AsyncStorage, 'setItem').mockRejectedValueOnce(new Error('Storage full'));\n-\n-      await expect(\n-        storageAdapter.setItem('test-key', 'test-value')\n-      ).rejects.toThrow('Failed to store item with key \"test-key\": Error: Storage full');\n-\n-      // Restore the mock\n-      AsyncStorage.setItem.mockRestore();\n-    });\n-\n-    it('should handle network errors gracefully', async () => {\n-      (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n-\n-      await expect(\n-        httpAdapter.post('https://api.example.com/token', {})\n-      ).rejects.toThrow('Network request failed: Error: Network error');\n-    });\n-\n-    it('should handle PKCE generation errors gracefully', async () => {\n-      // Mock crypto error\n-      const mockCrypto = require('expo-crypto');\n-      mockCrypto.digestStringAsync.mockRejectedValueOnce(new Error('Crypto error'));\n-\n-      await expect(pkceAdapter.generateCodeChallenge()).rejects.toThrow('Crypto error');\n-    });\n-  });\n-\n-  describe('Real-world Scenarios', () => {\n-    it('should handle complete authorization code flow', async () => {\n-      // 1. Generate authorization URL (this stores PKCE params internally)\n-      const authResult = await adapter.generateAuthorizationUrl();\n-      expect(authResult.url).toBeTruthy();\n-      expect(authResult.state).toBeTruthy();\n-\n-      // 2. Simulate callback with authorization code\n-      const callbackParams = {\n-        code: 'authorization-code-123',\n-        state: authResult.state,\n-      };\n-\n-      // Mock token exchange response\n-      const mockTokenResponse = {\n-        ok: true,\n-        status: 200,\n-        headers: new Map([['content-type', 'application/json']]),\n-        json: () => Promise.resolve({\n-          access_token: 'access-token-123',\n-          refresh_token: 'refresh-token-456',\n-          expires_in: 3600,\n-        }),\n-      };\n-      mockTokenResponse.headers.forEach = jest.fn((callback) => {\n-        callback('application/json', 'content-type');\n-      });\n-      (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n-\n-      // 3. Handle callback using the adapter (this will use OAuthCore internally)\n-      const result = await adapter.handleCallback(callbackParams);\n-\n-      // 4. Verify the callback was successful\n-      expect(result.success).toBe(true);\n-      expect(result.accessToken).toBe('access-token-123');\n-\n-      // 5. Verify authentication state\n-      expect(await adapter.isAuthenticated()).toBe(true);\n-      expect(await adapter.getAccessToken()).toBe('access-token-123');\n-    });\n-  });\n-});\n"
                },
                {
                    "date": 1752931544689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -285,17 +285,17 @@\n         callback('application/json', 'content-type');\n       });\n       (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n \n-      // 3. Handle callback using the adapter (this will use OAuthCore internally)\n-      const result = await adapter.handleCallback(callbackParams);\n+      // 3. Handle callback using the same adapter instance (this will use OAuthCore internally)\n+      const result = await flowAdapter.handleCallback(callbackParams);\n \n       // 4. Verify the callback was successful\n       expect(result.success).toBe(true);\n       expect(result.accessToken).toBe('access-token-123');\n \n       // 5. Verify authentication state\n-      expect(await adapter.isAuthenticated()).toBe(true);\n-      expect(await adapter.getAccessToken()).toBe('access-token-123');\n+      expect(await flowAdapter.isAuthenticated()).toBe(true);\n+      expect(await flowAdapter.getAccessToken()).toBe('access-token-123');\n     });\n   });\n });\n"
                },
                {
                    "date": 1752931633551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,8 +263,13 @@\n       const authResult = await flowAdapter.generateAuthorizationUrl();\n       expect(authResult.url).toBeTruthy();\n       expect(authResult.state).toBeTruthy();\n \n+      // Debug: Check if state is actually stored\n+      const storedState = await storageAdapter.getItem('oauth_state');\n+      console.log('Generated state:', authResult.state);\n+      console.log('Stored state:', storedState);\n+\n       // 2. Simulate callback with authorization code using the same state\n       const callbackParams = {\n         code: 'authorization-code-123',\n         state: authResult.state, // Use the actual state from the authorization URL\n"
                },
                {
                    "date": 1752931664257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,309 @@\n+import { ExpoOAuthAdapter } from '../../ExpoOAuthAdapter';\n+import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../../adapters';\n+import type { ExpoOAuthConfig } from '../../types';\n+\n+// Integration tests that test the full OAuth flow without mocking internal components\n+describe('OAuth Flow Integration Tests', () => {\n+  let adapter: ExpoOAuthAdapter;\n+  let storageAdapter: ExpoStorageAdapter;\n+  let httpAdapter: ExpoHttpAdapter;\n+  let pkceAdapter: ExpoPKCEAdapter;\n+\n+  const mockConfig: ExpoOAuthConfig = {\n+    clientId: 'test-client-id',\n+    endpoints: {\n+      authorization: 'https://auth.example.com/authorize',\n+      token: 'https://auth.example.com/token',\n+    },\n+    redirectUri: 'myapp://oauth/callback',\n+    scopes: ['read', 'write'],\n+  };\n+\n+  beforeEach(() => {\n+    // Clear mock storage between tests\n+    (global as any).clearMockStorage?.();\n+\n+    // Use real adapter instances for integration testing\n+    storageAdapter = new ExpoStorageAdapter();\n+    httpAdapter = new ExpoHttpAdapter();\n+    pkceAdapter = new ExpoPKCEAdapter();\n+    adapter = new ExpoOAuthAdapter(mockConfig);\n+  });\n+\n+  describe('PKCE Parameter Generation', () => {\n+    it('should generate valid PKCE parameters', async () => {\n+      const params = await adapter.generatePKCEParams();\n+\n+      expect(params).toHaveProperty('codeChallenge');\n+      expect(params).toHaveProperty('codeChallengeMethod', 'S256');\n+      expect(params).toHaveProperty('codeVerifier');\n+      expect(params).toHaveProperty('state');\n+\n+      // Verify code verifier format (128 characters, unreserved chars only)\n+      expect(params.codeVerifier).toHaveLength(128);\n+      expect(params.codeVerifier).toMatch(/^[A-Za-z0-9\\-\\._~]+$/);\n+\n+      // Verify code challenge is base64url encoded\n+      expect(params.codeChallenge).toMatch(/^[A-Za-z0-9\\-_]+$/);\n+      expect(params.codeChallenge).not.toContain('=');\n+      expect(params.codeChallenge).not.toContain('+');\n+      expect(params.codeChallenge).not.toContain('/');\n+\n+      // Verify state is a UUID\n+      expect(params.state).toMatch(\n+        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n+      );\n+    });\n+\n+    it('should generate different parameters on each call', async () => {\n+      const params1 = await adapter.generatePKCEParams();\n+      const params2 = await adapter.generatePKCEParams();\n+\n+      expect(params1.codeVerifier).not.toBe(params2.codeVerifier);\n+      expect(params1.codeChallenge).not.toBe(params2.codeChallenge);\n+      expect(params1.state).not.toBe(params2.state);\n+    });\n+  });\n+\n+  describe('Storage Integration', () => {\n+    it('should store and retrieve tokens correctly', async () => {\n+      const tokens = {\n+        accessToken: 'access-token-123',\n+        refreshToken: 'refresh-token-456',\n+        expiresIn: 3600,\n+      };\n+\n+      await storageAdapter.storeTokens(tokens);\n+\n+      const retrievedTokens = await storageAdapter.getTokens();\n+      expect(retrievedTokens.accessToken).toBe('access-token-123');\n+      expect(retrievedTokens.refreshToken).toBe('refresh-token-456');\n+      expect(retrievedTokens.expiresAt).toBeGreaterThan(Date.now());\n+    });\n+\n+    it('should handle token expiration correctly', async () => {\n+      // Store expired token\n+      const expiredTime = Date.now() - 1000;\n+      await storageAdapter.storeTokens({\n+        accessToken: 'expired-token',\n+        expiresIn: -1, // Already expired\n+      });\n+\n+      const isExpired = await storageAdapter.isTokenExpired();\n+      expect(isExpired).toBe(true);\n+    });\n+\n+    it('should clear all OAuth storage', async () => {\n+      // Store some data\n+      await storageAdapter.storeTokens({\n+        accessToken: 'token-123',\n+        refreshToken: 'refresh-456',\n+      });\n+      await storageAdapter.setItem('oauth_state', 'state-789');\n+      await storageAdapter.setItem('oauth_code_verifier', 'verifier-abc');\n+\n+      // Clear OAuth storage\n+      await storageAdapter.clearOAuthStorage();\n+\n+      // Verify all OAuth data is cleared\n+      const tokens = await storageAdapter.getTokens();\n+      expect(tokens.accessToken).toBeNull();\n+      expect(tokens.refreshToken).toBeNull();\n+      expect(tokens.expiresAt).toBeNull();\n+\n+      const state = await storageAdapter.getItem('oauth_state');\n+      const verifier = await storageAdapter.getItem('oauth_code_verifier');\n+      expect(state).toBeNull();\n+      expect(verifier).toBeNull();\n+    });\n+  });\n+\n+  describe('HTTP Adapter Integration', () => {\n+    it('should make POST requests with JSON data', async () => {\n+      // Mock successful response\n+      const mockResponse = {\n+        ok: true,\n+        status: 200,\n+        headers: new Map([['content-type', 'application/json']]),\n+        json: () => Promise.resolve({ access_token: 'token-123' }),\n+      };\n+      mockResponse.headers.forEach = jest.fn((callback) => {\n+        callback('application/json', 'content-type');\n+      });\n+      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n+\n+      const result = await httpAdapter.post('https://api.example.com/token', {\n+        grant_type: 'authorization_code',\n+        code: 'auth-code',\n+      });\n+\n+      expect(result.status).toBe(200);\n+      expect(result.data).toEqual({ access_token: 'token-123' });\n+      expect(global.fetch).toHaveBeenCalledWith(\n+        'https://api.example.com/token',\n+        expect.objectContaining({\n+          method: 'POST',\n+          headers: expect.objectContaining({\n+            'Content-Type': 'application/json',\n+          }),\n+          body: JSON.stringify({\n+            grant_type: 'authorization_code',\n+            code: 'auth-code',\n+          }),\n+        })\n+      );\n+    });\n+\n+    it('should make GET requests correctly', async () => {\n+      const mockResponse = {\n+        ok: true,\n+        status: 200,\n+        headers: new Map([['content-type', 'application/json']]),\n+        json: () => Promise.resolve({ user: 'john' }),\n+      };\n+      mockResponse.headers.forEach = jest.fn((callback) => {\n+        callback('application/json', 'content-type');\n+      });\n+      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n+\n+      const result = await httpAdapter.get('https://api.example.com/user', {\n+        Authorization: 'Bearer token-123',\n+      });\n+\n+      expect(result.status).toBe(200);\n+      expect(result.data).toEqual({ user: 'john' });\n+      expect(global.fetch).toHaveBeenCalledWith(\n+        'https://api.example.com/user',\n+        expect.objectContaining({\n+          method: 'GET',\n+          headers: expect.objectContaining({\n+            Authorization: 'Bearer token-123',\n+          }),\n+        })\n+      );\n+    });\n+  });\n+\n+  describe('Authentication State Management', () => {\n+    it('should correctly determine authentication status', async () => {\n+      // Initially not authenticated\n+      expect(await adapter.isAuthenticated()).toBe(false);\n+\n+      // Store valid tokens\n+      await storageAdapter.storeTokens({\n+        accessToken: 'valid-token',\n+        expiresIn: 3600,\n+      });\n+\n+      expect(await adapter.isAuthenticated()).toBe(true);\n+\n+      // Clear tokens\n+      await adapter.logout();\n+\n+      expect(await adapter.isAuthenticated()).toBe(false);\n+    });\n+\n+    it('should handle expired tokens correctly', async () => {\n+      // Store expired token\n+      await storageAdapter.storeTokens({\n+        accessToken: 'expired-token',\n+        expiresIn: -1,\n+      });\n+\n+      // Should not be authenticated with expired token\n+      expect(await adapter.isAuthenticated()).toBe(false);\n+\n+      // Getting access token should clear storage and return null\n+      const token = await adapter.getAccessToken();\n+      expect(token).toBeNull();\n+\n+      // Verify storage was cleared\n+      const tokens = await storageAdapter.getTokens();\n+      expect(tokens.accessToken).toBeNull();\n+    });\n+  });\n+\n+  describe('Error Handling', () => {\n+    it('should handle storage errors gracefully', async () => {\n+      // Mock AsyncStorage directly to trigger the error handling in our adapter\n+      const AsyncStorage = require('@react-native-async-storage/async-storage');\n+      jest.spyOn(AsyncStorage, 'setItem').mockRejectedValueOnce(new Error('Storage full'));\n+\n+      await expect(\n+        storageAdapter.setItem('test-key', 'test-value')\n+      ).rejects.toThrow('Failed to store item with key \"test-key\": Error: Storage full');\n+\n+      // Restore the mock\n+      AsyncStorage.setItem.mockRestore();\n+    });\n+\n+    it('should handle network errors gracefully', async () => {\n+      (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n+\n+      await expect(\n+        httpAdapter.post('https://api.example.com/token', {})\n+      ).rejects.toThrow('Network request failed: Error: Network error');\n+    });\n+\n+    it('should handle PKCE generation errors gracefully', async () => {\n+      // Mock crypto error\n+      const mockCrypto = require('expo-crypto');\n+      mockCrypto.digestStringAsync.mockRejectedValueOnce(new Error('Crypto error'));\n+\n+      await expect(pkceAdapter.generateCodeChallenge()).rejects.toThrow('Crypto error');\n+    });\n+  });\n+\n+  describe('Real-world Scenarios', () => {\n+    it('should handle complete authorization code flow', async () => {\n+      // Create a dedicated adapter instance for this test to maintain state\n+      const flowAdapter = new ExpoOAuthAdapter(mockConfig);\n+\n+      // 1. Generate authorization URL (this stores PKCE params internally)\n+      const authResult = await flowAdapter.generateAuthorizationUrl();\n+      expect(authResult.url).toBeTruthy();\n+      expect(authResult.state).toBeTruthy();\n+\n+      // Debug: Check if state is actually stored\n+      const storedState = await storageAdapter.getItem('oauth_state');\n+      console.log('Generated state:', authResult.state);\n+      console.log('Stored state:', storedState);\n+\n+      // 2. Simulate callback with authorization code using the same state\n+      const callbackParams = {\n+        code: 'authorization-code-123',\n+        state: authResult.state, // Use the actual state from the authorization URL\n+      };\n+\n+      // Mock token exchange response\n+      const mockTokenResponse = {\n+        ok: true,\n+        status: 200,\n+        headers: new Map([['content-type', 'application/json']]),\n+        json: () => Promise.resolve({\n+          access_token: 'access-token-123',\n+          refresh_token: 'refresh-token-456',\n+          expires_in: 3600,\n+        }),\n+      };\n+      mockTokenResponse.headers.forEach = jest.fn((callback) => {\n+        callback('application/json', 'content-type');\n+      });\n+      (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n+\n+      // 3. Handle callback using the same adapter instance (this will use OAuthCore internally)\n+      const result = await flowAdapter.handleCallback(callbackParams);\n+\n+      // Debug: Check the result\n+      console.log('Callback result:', result);\n+\n+      // 4. Verify the callback was successful\n+      expect(result.success).toBe(true);\n+      expect(result.accessToken).toBe('access-token-123');\n+\n+      // 5. Verify authentication state\n+      expect(await flowAdapter.isAuthenticated()).toBe(true);\n+      expect(await flowAdapter.getAccessToken()).toBe('access-token-123');\n+    });\n+  });\n+});\n"
                },
                {
                    "date": 1752931755778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,13 +263,8 @@\n       const authResult = await flowAdapter.generateAuthorizationUrl();\n       expect(authResult.url).toBeTruthy();\n       expect(authResult.state).toBeTruthy();\n \n-      // Debug: Check if state is actually stored\n-      const storedState = await storageAdapter.getItem('oauth_state');\n-      console.log('Generated state:', authResult.state);\n-      console.log('Stored state:', storedState);\n-\n       // 2. Simulate callback with authorization code using the same state\n       const callbackParams = {\n         code: 'authorization-code-123',\n         state: authResult.state, // Use the actual state from the authorization URL\n"
                },
                {
                    "date": 1752931768642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -288,11 +288,8 @@\n \n       // 3. Handle callback using the same adapter instance (this will use OAuthCore internally)\n       const result = await flowAdapter.handleCallback(callbackParams);\n \n-      // Debug: Check the result\n-      console.log('Callback result:', result);\n-\n       // 4. Verify the callback was successful\n       expect(result.success).toBe(true);\n       expect(result.accessToken).toBe('access-token-123');\n \n@@ -301,310 +298,4 @@\n       expect(await flowAdapter.getAccessToken()).toBe('access-token-123');\n     });\n   });\n });\n-import { ExpoOAuthAdapter } from '../../ExpoOAuthAdapter';\n-import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../../adapters';\n-import type { ExpoOAuthConfig } from '../../types';\n-\n-// Integration tests that test the full OAuth flow without mocking internal components\n-describe('OAuth Flow Integration Tests', () => {\n-  let adapter: ExpoOAuthAdapter;\n-  let storageAdapter: ExpoStorageAdapter;\n-  let httpAdapter: ExpoHttpAdapter;\n-  let pkceAdapter: ExpoPKCEAdapter;\n-\n-  const mockConfig: ExpoOAuthConfig = {\n-    clientId: 'test-client-id',\n-    endpoints: {\n-      authorization: 'https://auth.example.com/authorize',\n-      token: 'https://auth.example.com/token',\n-    },\n-    redirectUri: 'myapp://oauth/callback',\n-    scopes: ['read', 'write'],\n-  };\n-\n-  beforeEach(() => {\n-    // Clear mock storage between tests\n-    (global as any).clearMockStorage?.();\n-\n-    // Use real adapter instances for integration testing\n-    storageAdapter = new ExpoStorageAdapter();\n-    httpAdapter = new ExpoHttpAdapter();\n-    pkceAdapter = new ExpoPKCEAdapter();\n-    adapter = new ExpoOAuthAdapter(mockConfig);\n-  });\n-\n-  describe('PKCE Parameter Generation', () => {\n-    it('should generate valid PKCE parameters', async () => {\n-      const params = await adapter.generatePKCEParams();\n-\n-      expect(params).toHaveProperty('codeChallenge');\n-      expect(params).toHaveProperty('codeChallengeMethod', 'S256');\n-      expect(params).toHaveProperty('codeVerifier');\n-      expect(params).toHaveProperty('state');\n-\n-      // Verify code verifier format (128 characters, unreserved chars only)\n-      expect(params.codeVerifier).toHaveLength(128);\n-      expect(params.codeVerifier).toMatch(/^[A-Za-z0-9\\-\\._~]+$/);\n-\n-      // Verify code challenge is base64url encoded\n-      expect(params.codeChallenge).toMatch(/^[A-Za-z0-9\\-_]+$/);\n-      expect(params.codeChallenge).not.toContain('=');\n-      expect(params.codeChallenge).not.toContain('+');\n-      expect(params.codeChallenge).not.toContain('/');\n-\n-      // Verify state is a UUID\n-      expect(params.state).toMatch(\n-        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n-      );\n-    });\n-\n-    it('should generate different parameters on each call', async () => {\n-      const params1 = await adapter.generatePKCEParams();\n-      const params2 = await adapter.generatePKCEParams();\n-\n-      expect(params1.codeVerifier).not.toBe(params2.codeVerifier);\n-      expect(params1.codeChallenge).not.toBe(params2.codeChallenge);\n-      expect(params1.state).not.toBe(params2.state);\n-    });\n-  });\n-\n-  describe('Storage Integration', () => {\n-    it('should store and retrieve tokens correctly', async () => {\n-      const tokens = {\n-        accessToken: 'access-token-123',\n-        refreshToken: 'refresh-token-456',\n-        expiresIn: 3600,\n-      };\n-\n-      await storageAdapter.storeTokens(tokens);\n-\n-      const retrievedTokens = await storageAdapter.getTokens();\n-      expect(retrievedTokens.accessToken).toBe('access-token-123');\n-      expect(retrievedTokens.refreshToken).toBe('refresh-token-456');\n-      expect(retrievedTokens.expiresAt).toBeGreaterThan(Date.now());\n-    });\n-\n-    it('should handle token expiration correctly', async () => {\n-      // Store expired token\n-      const expiredTime = Date.now() - 1000;\n-      await storageAdapter.storeTokens({\n-        accessToken: 'expired-token',\n-        expiresIn: -1, // Already expired\n-      });\n-\n-      const isExpired = await storageAdapter.isTokenExpired();\n-      expect(isExpired).toBe(true);\n-    });\n-\n-    it('should clear all OAuth storage', async () => {\n-      // Store some data\n-      await storageAdapter.storeTokens({\n-        accessToken: 'token-123',\n-        refreshToken: 'refresh-456',\n-      });\n-      await storageAdapter.setItem('oauth_state', 'state-789');\n-      await storageAdapter.setItem('oauth_code_verifier', 'verifier-abc');\n-\n-      // Clear OAuth storage\n-      await storageAdapter.clearOAuthStorage();\n-\n-      // Verify all OAuth data is cleared\n-      const tokens = await storageAdapter.getTokens();\n-      expect(tokens.accessToken).toBeNull();\n-      expect(tokens.refreshToken).toBeNull();\n-      expect(tokens.expiresAt).toBeNull();\n-\n-      const state = await storageAdapter.getItem('oauth_state');\n-      const verifier = await storageAdapter.getItem('oauth_code_verifier');\n-      expect(state).toBeNull();\n-      expect(verifier).toBeNull();\n-    });\n-  });\n-\n-  describe('HTTP Adapter Integration', () => {\n-    it('should make POST requests with JSON data', async () => {\n-      // Mock successful response\n-      const mockResponse = {\n-        ok: true,\n-        status: 200,\n-        headers: new Map([['content-type', 'application/json']]),\n-        json: () => Promise.resolve({ access_token: 'token-123' }),\n-      };\n-      mockResponse.headers.forEach = jest.fn((callback) => {\n-        callback('application/json', 'content-type');\n-      });\n-      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n-\n-      const result = await httpAdapter.post('https://api.example.com/token', {\n-        grant_type: 'authorization_code',\n-        code: 'auth-code',\n-      });\n-\n-      expect(result.status).toBe(200);\n-      expect(result.data).toEqual({ access_token: 'token-123' });\n-      expect(global.fetch).toHaveBeenCalledWith(\n-        'https://api.example.com/token',\n-        expect.objectContaining({\n-          method: 'POST',\n-          headers: expect.objectContaining({\n-            'Content-Type': 'application/json',\n-          }),\n-          body: JSON.stringify({\n-            grant_type: 'authorization_code',\n-            code: 'auth-code',\n-          }),\n-        })\n-      );\n-    });\n-\n-    it('should make GET requests correctly', async () => {\n-      const mockResponse = {\n-        ok: true,\n-        status: 200,\n-        headers: new Map([['content-type', 'application/json']]),\n-        json: () => Promise.resolve({ user: 'john' }),\n-      };\n-      mockResponse.headers.forEach = jest.fn((callback) => {\n-        callback('application/json', 'content-type');\n-      });\n-      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n-\n-      const result = await httpAdapter.get('https://api.example.com/user', {\n-        Authorization: 'Bearer token-123',\n-      });\n-\n-      expect(result.status).toBe(200);\n-      expect(result.data).toEqual({ user: 'john' });\n-      expect(global.fetch).toHaveBeenCalledWith(\n-        'https://api.example.com/user',\n-        expect.objectContaining({\n-          method: 'GET',\n-          headers: expect.objectContaining({\n-            Authorization: 'Bearer token-123',\n-          }),\n-        })\n-      );\n-    });\n-  });\n-\n-  describe('Authentication State Management', () => {\n-    it('should correctly determine authentication status', async () => {\n-      // Initially not authenticated\n-      expect(await adapter.isAuthenticated()).toBe(false);\n-\n-      // Store valid tokens\n-      await storageAdapter.storeTokens({\n-        accessToken: 'valid-token',\n-        expiresIn: 3600,\n-      });\n-\n-      expect(await adapter.isAuthenticated()).toBe(true);\n-\n-      // Clear tokens\n-      await adapter.logout();\n-\n-      expect(await adapter.isAuthenticated()).toBe(false);\n-    });\n-\n-    it('should handle expired tokens correctly', async () => {\n-      // Store expired token\n-      await storageAdapter.storeTokens({\n-        accessToken: 'expired-token',\n-        expiresIn: -1,\n-      });\n-\n-      // Should not be authenticated with expired token\n-      expect(await adapter.isAuthenticated()).toBe(false);\n-\n-      // Getting access token should clear storage and return null\n-      const token = await adapter.getAccessToken();\n-      expect(token).toBeNull();\n-\n-      // Verify storage was cleared\n-      const tokens = await storageAdapter.getTokens();\n-      expect(tokens.accessToken).toBeNull();\n-    });\n-  });\n-\n-  describe('Error Handling', () => {\n-    it('should handle storage errors gracefully', async () => {\n-      // Mock AsyncStorage directly to trigger the error handling in our adapter\n-      const AsyncStorage = require('@react-native-async-storage/async-storage');\n-      jest.spyOn(AsyncStorage, 'setItem').mockRejectedValueOnce(new Error('Storage full'));\n-\n-      await expect(\n-        storageAdapter.setItem('test-key', 'test-value')\n-      ).rejects.toThrow('Failed to store item with key \"test-key\": Error: Storage full');\n-\n-      // Restore the mock\n-      AsyncStorage.setItem.mockRestore();\n-    });\n-\n-    it('should handle network errors gracefully', async () => {\n-      (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n-\n-      await expect(\n-        httpAdapter.post('https://api.example.com/token', {})\n-      ).rejects.toThrow('Network request failed: Error: Network error');\n-    });\n-\n-    it('should handle PKCE generation errors gracefully', async () => {\n-      // Mock crypto error\n-      const mockCrypto = require('expo-crypto');\n-      mockCrypto.digestStringAsync.mockRejectedValueOnce(new Error('Crypto error'));\n-\n-      await expect(pkceAdapter.generateCodeChallenge()).rejects.toThrow('Crypto error');\n-    });\n-  });\n-\n-  describe('Real-world Scenarios', () => {\n-    it('should handle complete authorization code flow', async () => {\n-      // Create a dedicated adapter instance for this test to maintain state\n-      const flowAdapter = new ExpoOAuthAdapter(mockConfig);\n-\n-      // 1. Generate authorization URL (this stores PKCE params internally)\n-      const authResult = await flowAdapter.generateAuthorizationUrl();\n-      expect(authResult.url).toBeTruthy();\n-      expect(authResult.state).toBeTruthy();\n-\n-      // Debug: Check if state is actually stored\n-      const storedState = await storageAdapter.getItem('oauth_state');\n-      console.log('Generated state:', authResult.state);\n-      console.log('Stored state:', storedState);\n-\n-      // 2. Simulate callback with authorization code using the same state\n-      const callbackParams = {\n-        code: 'authorization-code-123',\n-        state: authResult.state, // Use the actual state from the authorization URL\n-      };\n-\n-      // Mock token exchange response\n-      const mockTokenResponse = {\n-        ok: true,\n-        status: 200,\n-        headers: new Map([['content-type', 'application/json']]),\n-        json: () => Promise.resolve({\n-          access_token: 'access-token-123',\n-          refresh_token: 'refresh-token-456',\n-          expires_in: 3600,\n-        }),\n-      };\n-      mockTokenResponse.headers.forEach = jest.fn((callback) => {\n-        callback('application/json', 'content-type');\n-      });\n-      (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n-\n-      // 3. Handle callback using the same adapter instance (this will use OAuthCore internally)\n-      const result = await flowAdapter.handleCallback(callbackParams);\n-\n-      // 4. Verify the callback was successful\n-      expect(result.success).toBe(true);\n-      expect(result.accessToken).toBe('access-token-123');\n-\n-      // 5. Verify authentication state\n-      expect(await flowAdapter.isAuthenticated()).toBe(true);\n-      expect(await flowAdapter.getAccessToken()).toBe('access-token-123');\n-    });\n-  });\n-});\n"
                },
                {
                    "date": 1752999533721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,5 +295,8 @@\n       expect(result.accessToken).toBe('access-token-123');\n \n       // 5. Verify authentication state\n       expect(await flowAdapter.isAuthenticated()).toBe(true);\n-      expect(await flowAdapter.getAccessToken()).to\n\\ No newline at end of file\n+      expect(await flowAdapter.getAccessToken()).toBe('access-token-123');\n+    });\n+  });\n+});\n"
                },
                {
                    "date": 1753000331795,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -286,8 +286,16 @@\n         callback('application/json', 'content-type');\n       });\n       (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n \n+      // Debug: Check what's stored in storage before callback\n+      const storedState = await storageAdapter.getItem('oauth_state');\n+      const storedStateExpiry = await storageAdapter.getItem('oauth_state_expiry');\n+      console.log('DEBUG: Stored state:', storedState);\n+      console.log('DEBUG: Stored state expiry:', storedStateExpiry);\n+      console.log('DEBUG: Current time:', Date.now());\n+      console.log('DEBUG: Callback state:', callbackParams.state);\n+\n       // 3. Handle callback using the same adapter instance (this will use OAuthCore internally)\n       const result = await flowAdapter.handleCallback(callbackParams);\n \n       // 4. Verify the callback was successful\n"
                }
            ],
            "date": 1752908137044,
            "name": "Commit-0",
            "content": "import { ExpoOAuthAdapter } from '../../ExpoOAuthAdapter';\nimport { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../../adapters';\nimport type { ExpoOAuthConfig } from '../../types';\n\n// Integration tests that test the full OAuth flow without mocking internal components\ndescribe('OAuth Flow Integration Tests', () => {\n  let adapter: ExpoOAuthAdapter;\n  let storageAdapter: ExpoStorageAdapter;\n  let httpAdapter: ExpoHttpAdapter;\n  let pkceAdapter: ExpoPKCEAdapter;\n\n  const mockConfig: ExpoOAuthConfig = {\n    clientId: 'test-client-id',\n    endpoints: {\n      authorization: 'https://auth.example.com/authorize',\n      token: 'https://auth.example.com/token',\n    },\n    redirectUri: 'myapp://oauth/callback',\n    scopes: ['read', 'write'],\n  };\n\n  beforeEach(() => {\n    // Clear mock storage between tests\n    (global as any).clearMockStorage?.();\n\n    // Use real adapter instances for integration testing\n    storageAdapter = new ExpoStorageAdapter();\n    httpAdapter = new ExpoHttpAdapter();\n    pkceAdapter = new ExpoPKCEAdapter();\n    adapter = new ExpoOAuthAdapter(mockConfig);\n  });\n\n  describe('PKCE Parameter Generation', () => {\n    it('should generate valid PKCE parameters', async () => {\n      const params = await adapter.generatePKCEParams();\n\n      expect(params).toHaveProperty('codeChallenge');\n      expect(params).toHaveProperty('codeChallengeMethod', 'S256');\n      expect(params).toHaveProperty('codeVerifier');\n      expect(params).toHaveProperty('state');\n\n      // Verify code verifier format (128 characters, unreserved chars only)\n      expect(params.codeVerifier).toHaveLength(128);\n      expect(params.codeVerifier).toMatch(/^[A-Za-z0-9\\-\\._~]+$/);\n\n      // Verify code challenge is base64url encoded\n      expect(params.codeChallenge).toMatch(/^[A-Za-z0-9\\-_]+$/);\n      expect(params.codeChallenge).not.toContain('=');\n      expect(params.codeChallenge).not.toContain('+');\n      expect(params.codeChallenge).not.toContain('/');\n\n      // Verify state is a UUID\n      expect(params.state).toMatch(\n        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n      );\n    });\n\n    it('should generate different parameters on each call', async () => {\n      const params1 = await adapter.generatePKCEParams();\n      const params2 = await adapter.generatePKCEParams();\n\n      expect(params1.codeVerifier).not.toBe(params2.codeVerifier);\n      expect(params1.codeChallenge).not.toBe(params2.codeChallenge);\n      expect(params1.state).not.toBe(params2.state);\n    });\n  });\n\n  describe('Storage Integration', () => {\n    it('should store and retrieve tokens correctly', async () => {\n      const tokens = {\n        accessToken: 'access-token-123',\n        refreshToken: 'refresh-token-456',\n        expiresIn: 3600,\n      };\n\n      await storageAdapter.storeTokens(tokens);\n\n      const retrievedTokens = await storageAdapter.getTokens();\n      expect(retrievedTokens.accessToken).toBe('access-token-123');\n      expect(retrievedTokens.refreshToken).toBe('refresh-token-456');\n      expect(retrievedTokens.expiresAt).toBeGreaterThan(Date.now());\n    });\n\n    it('should handle token expiration correctly', async () => {\n      // Store expired token\n      const expiredTime = Date.now() - 1000;\n      await storageAdapter.storeTokens({\n        accessToken: 'expired-token',\n        expiresIn: -1, // Already expired\n      });\n\n      const isExpired = await storageAdapter.isTokenExpired();\n      expect(isExpired).toBe(true);\n    });\n\n    it('should clear all OAuth storage', async () => {\n      // Store some data\n      await storageAdapter.storeTokens({\n        accessToken: 'token-123',\n        refreshToken: 'refresh-456',\n      });\n      await storageAdapter.setItem('oauth_state', 'state-789');\n      await storageAdapter.setItem('oauth_code_verifier', 'verifier-abc');\n\n      // Clear OAuth storage\n      await storageAdapter.clearOAuthStorage();\n\n      // Verify all OAuth data is cleared\n      const tokens = await storageAdapter.getTokens();\n      expect(tokens.accessToken).toBeNull();\n      expect(tokens.refreshToken).toBeNull();\n      expect(tokens.expiresAt).toBeNull();\n\n      const state = await storageAdapter.getItem('oauth_state');\n      const verifier = await storageAdapter.getItem('oauth_code_verifier');\n      expect(state).toBeNull();\n      expect(verifier).toBeNull();\n    });\n  });\n\n  describe('HTTP Adapter Integration', () => {\n    it('should make POST requests with JSON data', async () => {\n      // Mock successful response\n      const mockResponse = {\n        ok: true,\n        status: 200,\n        headers: new Map([['content-type', 'application/json']]),\n        json: () => Promise.resolve({ access_token: 'token-123' }),\n      };\n      mockResponse.headers.forEach = jest.fn((callback) => {\n        callback('application/json', 'content-type');\n      });\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n\n      const result = await httpAdapter.post('https://api.example.com/token', {\n        grant_type: 'authorization_code',\n        code: 'auth-code',\n      });\n\n      expect(result.status).toBe(200);\n      expect(result.data).toEqual({ access_token: 'token-123' });\n      expect(global.fetch).toHaveBeenCalledWith(\n        'https://api.example.com/token',\n        expect.objectContaining({\n          method: 'POST',\n          headers: expect.objectContaining({\n            'Content-Type': 'application/json',\n          }),\n          body: JSON.stringify({\n            grant_type: 'authorization_code',\n            code: 'auth-code',\n          }),\n        })\n      );\n    });\n\n    it('should make GET requests correctly', async () => {\n      const mockResponse = {\n        ok: true,\n        status: 200,\n        headers: new Map([['content-type', 'application/json']]),\n        json: () => Promise.resolve({ user: 'john' }),\n      };\n      mockResponse.headers.forEach = jest.fn((callback) => {\n        callback('application/json', 'content-type');\n      });\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\n\n      const result = await httpAdapter.get('https://api.example.com/user', {\n        Authorization: 'Bearer token-123',\n      });\n\n      expect(result.status).toBe(200);\n      expect(result.data).toEqual({ user: 'john' });\n      expect(global.fetch).toHaveBeenCalledWith(\n        'https://api.example.com/user',\n        expect.objectContaining({\n          method: 'GET',\n          headers: expect.objectContaining({\n            Authorization: 'Bearer token-123',\n          }),\n        })\n      );\n    });\n  });\n\n  describe('Authentication State Management', () => {\n    it('should correctly determine authentication status', async () => {\n      // Initially not authenticated\n      expect(await adapter.isAuthenticated()).toBe(false);\n\n      // Store valid tokens\n      await storageAdapter.storeTokens({\n        accessToken: 'valid-token',\n        expiresIn: 3600,\n      });\n\n      expect(await adapter.isAuthenticated()).toBe(true);\n\n      // Clear tokens\n      await adapter.logout();\n\n      expect(await adapter.isAuthenticated()).toBe(false);\n    });\n\n    it('should handle expired tokens correctly', async () => {\n      // Store expired token\n      await storageAdapter.storeTokens({\n        accessToken: 'expired-token',\n        expiresIn: -1,\n      });\n\n      // Should not be authenticated with expired token\n      expect(await adapter.isAuthenticated()).toBe(false);\n\n      // Getting access token should clear storage and return null\n      const token = await adapter.getAccessToken();\n      expect(token).toBeNull();\n\n      // Verify storage was cleared\n      const tokens = await storageAdapter.getTokens();\n      expect(tokens.accessToken).toBeNull();\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle storage errors gracefully', async () => {\n      // Mock storage error\n      jest.spyOn(storageAdapter, 'setItem').mockRejectedValueOnce(new Error('Storage full'));\n\n      await expect(\n        storageAdapter.setItem('test-key', 'test-value')\n      ).rejects.toThrow('Failed to store item with key \"test-key\": Error: Storage full');\n    });\n\n    it('should handle network errors gracefully', async () => {\n      (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n\n      await expect(\n        httpAdapter.post('https://api.example.com/token', {})\n      ).rejects.toThrow('Network request failed: Error: Network error');\n    });\n\n    it('should handle PKCE generation errors gracefully', async () => {\n      // Mock crypto error\n      const mockCrypto = require('expo-crypto');\n      mockCrypto.digestStringAsync.mockRejectedValueOnce(new Error('Crypto error'));\n\n      await expect(pkceAdapter.generateCodeChallenge()).rejects.toThrow('Crypto error');\n    });\n  });\n\n  describe('Real-world Scenarios', () => {\n    it('should handle complete authorization code flow', async () => {\n      // 1. Generate PKCE parameters\n      const pkceParams = await adapter.generatePKCEParams();\n      expect(pkceParams).toHaveProperty('codeChallenge');\n      expect(pkceParams).toHaveProperty('state');\n\n      // 2. Simulate callback with authorization code\n      const callbackParams = {\n        code: 'authorization-code-123',\n        state: pkceParams.state,\n      };\n\n      // Mock token exchange response\n      const mockTokenResponse = {\n        ok: true,\n        status: 200,\n        headers: new Map([['content-type', 'application/json']]),\n        json: () => Promise.resolve({\n          access_token: 'access-token-123',\n          refresh_token: 'refresh-token-456',\n          expires_in: 3600,\n        }),\n      };\n      mockTokenResponse.headers.forEach = jest.fn((callback) => {\n        callback('application/json', 'content-type');\n      });\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockTokenResponse);\n\n      // 3. Handle callback (this would normally be done by OAuthCore)\n      // For integration test, we'll just verify the parameters are correct\n      expect(callbackParams.code).toBe('authorization-code-123');\n      expect(callbackParams.state).toBe(pkceParams.state);\n\n      // 4. Verify authentication state\n      // In a real scenario, tokens would be stored after successful callback\n      await storageAdapter.storeTokens({\n        accessToken: 'access-token-123',\n        refreshToken: 'refresh-token-456',\n        expiresIn: 3600,\n      });\n\n      expect(await adapter.isAuthenticated()).toBe(true);\n      expect(await adapter.getAccessToken()).toBe('access-token-123');\n    });\n  });\n});\n"
        }
    ]
}