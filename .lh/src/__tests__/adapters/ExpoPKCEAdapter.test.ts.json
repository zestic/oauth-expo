{
    "sourceFile": "src/__tests__/adapters/ExpoPKCEAdapter.test.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753013621292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753013621292,
            "name": "Commit-0",
            "content": "import * as Crypto from 'expo-crypto';\nimport { ExpoPKCEAdapter } from '../../adapters/ExpoPKCEAdapter';\n\n// Mock expo-crypto\njest.mock('expo-crypto', () => ({\n  randomUUID: jest.fn(),\n  digestStringAsync: jest.fn(),\n  CryptoDigestAlgorithm: {\n    SHA256: 'SHA256',\n  },\n  CryptoEncoding: {\n    BASE64: 'BASE64',\n  },\n}));\n\nconst mockCrypto = Crypto as jest.Mocked<typeof Crypto>;\n\ndescribe('ExpoPKCEAdapter', () => {\n  let adapter: ExpoPKCEAdapter;\n\n  beforeEach(() => {\n    adapter = new ExpoPKCEAdapter();\n    jest.clearAllMocks();\n  });\n\n  describe('generateCodeChallenge', () => {\n    it('should generate PKCE challenge with S256 method', async () => {\n      // Mock the SHA256 hash result (base64)\n      mockCrypto.digestStringAsync.mockResolvedValue(\n        'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk='\n      );\n\n      const result = await adapter.generateCodeChallenge();\n\n      expect(result).toEqual({\n        codeChallenge: 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk',\n        codeChallengeMethod: 'S256',\n        codeVerifier: expect.any(String),\n      });\n\n      expect(result.codeVerifier).toHaveLength(128);\n      expect(result.codeVerifier).toMatch(/^[A-Za-z0-9\\-\\._~]+$/);\n    });\n\n    it('should generate different code verifiers on each call', async () => {\n      mockCrypto.digestStringAsync\n        .mockResolvedValueOnce('hash1=')\n        .mockResolvedValueOnce('hash2=');\n\n      const result1 = await adapter.generateCodeChallenge();\n      const result2 = await adapter.generateCodeChallenge();\n\n      expect(result1.codeVerifier).not.toBe(result2.codeVerifier);\n      expect(result1.codeChallenge).not.toBe(result2.codeChallenge);\n    });\n\n    it('should convert base64 to base64url format', async () => {\n      // Mock base64 with padding and special characters\n      mockCrypto.digestStringAsync.mockResolvedValue(\n        'dBjftJeZ4CVP+mB92K27uhbUJU1p1r/wW1gFWFOEjXk='\n      );\n\n      const result = await adapter.generateCodeChallenge();\n\n      // Should convert + to -, / to _, and remove =\n      expect(result.codeChallenge).toBe(\n        'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk'\n      );\n    });\n\n    it('should call digestStringAsync with correct parameters', async () => {\n      mockCrypto.digestStringAsync.mockResolvedValue('test-hash=');\n\n      await adapter.generateCodeChallenge();\n\n      expect(mockCrypto.digestStringAsync).toHaveBeenCalledWith(\n        'SHA256',\n        expect.any(String), // the code verifier\n        { encoding: 'BASE64' }\n      );\n    });\n\n    it('should handle crypto errors', async () => {\n      mockCrypto.digestStringAsync.mockRejectedValue(new Error('Crypto error'));\n\n      await expect(adapter.generateCodeChallenge()).rejects.toThrow(\n        'Crypto error'\n      );\n    });\n  });\n\n  describe('generateState', () => {\n    it('should generate a random UUID state', async () => {\n      mockCrypto.randomUUID.mockReturnValue(\n        '550e8400-e29b-41d4-a716-446655440000'\n      );\n\n      const result = await adapter.generateState();\n\n      expect(result).toBe('550e8400-e29b-41d4-a716-446655440000');\n      expect(mockCrypto.randomUUID).toHaveBeenCalledTimes(1);\n    });\n\n    it('should generate different states on each call', async () => {\n      mockCrypto.randomUUID\n        .mockReturnValueOnce('550e8400-e29b-41d4-a716-446655440000')\n        .mockReturnValueOnce('6ba7b810-9dad-11d1-80b4-00c04fd430c8');\n\n      const state1 = await adapter.generateState();\n      const state2 = await adapter.generateState();\n\n      expect(state1).not.toBe(state2);\n      expect(state1).toBe('550e8400-e29b-41d4-a716-446655440000');\n      expect(state2).toBe('6ba7b810-9dad-11d1-80b4-00c04fd430c8');\n    });\n\n    it('should return a promise', async () => {\n      mockCrypto.randomUUID.mockReturnValue('test-uuid');\n\n      const result = adapter.generateState();\n\n      expect(result).toBeInstanceOf(Promise);\n      expect(await result).toBe('test-uuid');\n    });\n  });\n\n  describe('generateRandomString', () => {\n    it('should generate string of correct length', async () => {\n      mockCrypto.digestStringAsync.mockResolvedValue('test-hash=');\n\n      const result = await adapter.generateCodeChallenge();\n\n      // The code verifier should be 128 characters\n      expect(result.codeVerifier).toHaveLength(128);\n    });\n\n    it('should only contain valid characters', async () => {\n      mockCrypto.digestStringAsync.mockResolvedValue('test-hash=');\n\n      const result = await adapter.generateCodeChallenge();\n\n      // Should only contain unreserved characters as per RFC 7636\n      expect(result.codeVerifier).toMatch(/^[A-Za-z0-9\\-\\._~]+$/);\n    });\n  });\n\n  describe('sha256', () => {\n    it('should handle various input strings', async () => {\n      const testCases = [\n        {\n          input: 'test',\n          output: 'n4bQgYhMfWWaL+qgxVrQFaO/TxsrC4Is0V1sFbDwCgg=',\n        },\n        {\n          input: 'hello world',\n          output: 'uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek=',\n        },\n        { input: '', output: '47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=' },\n      ];\n\n      for (const testCase of testCases) {\n        mockCrypto.digestStringAsync.mockResolvedValue(testCase.output);\n\n        await adapter.generateCodeChallenge();\n\n        expect(mockCrypto.digestStringAsync).toHaveBeenCalledWith(\n          'SHA256',\n          expect.any(String),\n          { encoding: 'BASE64' }\n        );\n      }\n    });\n  });\n\n  describe('integration test', () => {\n    it('should generate valid PKCE parameters', async () => {\n      mockCrypto.randomUUID.mockReturnValue('test-state-uuid');\n      mockCrypto.digestStringAsync.mockResolvedValue(\n        'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk='\n      );\n\n      const challenge = await adapter.generateCodeChallenge();\n      const state = await adapter.generateState();\n\n      expect(challenge).toEqual({\n        codeChallenge: 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk',\n        codeChallengeMethod: 'S256',\n        codeVerifier: expect.any(String),\n      });\n\n      expect(state).toBe('test-state-uuid');\n\n      // Verify the code verifier is used to generate the challenge\n      expect(mockCrypto.digestStringAsync).toHaveBeenCalledWith(\n        'SHA256',\n        challenge.codeVerifier,\n        { encoding: 'BASE64' }\n      );\n    });\n  });\n});\n"
        }
    ]
}