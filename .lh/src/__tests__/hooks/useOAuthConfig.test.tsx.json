{
    "sourceFile": "src/__tests__/hooks/useOAuthConfig.test.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753013592812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753013592812,
            "name": "Commit-0",
            "content": "\nimport { renderHook, act } from '@testing-library/react-native';\nimport { useOAuthConfig } from '../../hooks/useOAuthConfig';\nimport { ExpoPKCEAdapter } from '../../adapters/ExpoPKCEAdapter';\n\n// Mock the PKCE adapter\njest.mock('../../adapters/ExpoPKCEAdapter');\n\nconst MockedExpoPKCEAdapter = ExpoPKCEAdapter as jest.MockedClass<\n  typeof ExpoPKCEAdapter\n>;\n\ndescribe('useOAuthConfig', () => {\n  let mockPKCEAdapter: jest.Mocked<ExpoPKCEAdapter>;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    mockPKCEAdapter = {\n      generateCodeChallenge: jest.fn(),\n      generateState: jest.fn(),\n    } as any;\n\n    MockedExpoPKCEAdapter.mockImplementation(() => mockPKCEAdapter);\n  });\n\n  describe('basic configuration', () => {\n    it('should create config with required parameters', () => {\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read', 'write'],\n        })\n      );\n\n      expect(result.current.config).toEqual({\n        clientId: 'test-client-id',\n        endpoints: {\n          authorization: 'https://auth.example.com/authorize',\n          token: 'https://auth.example.com/token',\n        },\n        redirectUri: 'myapp://oauth/callback',\n        scopes: ['read', 'write'],\n      });\n    });\n\n    it('should include optional parameters when provided', () => {\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read', 'write'],\n          scheme: 'myapp',\n          path: '/oauth/callback',\n          additionalParameters: {\n            audience: 'https://api.example.com',\n            prompt: 'consent',\n          },\n        })\n      );\n\n      expect(result.current.config).toEqual({\n        clientId: 'test-client-id',\n        endpoints: {\n          authorization: 'https://auth.example.com/authorize',\n          token: 'https://auth.example.com/token',\n        },\n        redirectUri: 'myapp://oauth/callback',\n        scopes: ['read', 'write'],\n        scheme: 'myapp',\n        path: '/oauth/callback',\n      });\n\n      expect(result.current.additionalParameters).toEqual({\n        audience: 'https://api.example.com',\n        prompt: 'consent',\n      });\n    });\n  });\n\n  describe('generateAuthUrl', () => {\n    it('should generate authorization URL with PKCE parameters', async () => {\n      const mockChallenge = {\n        codeChallenge: 'test-challenge',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'test-verifier',\n      };\n      const mockState = 'test-state';\n\n      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read', 'write'],\n        })\n      );\n\n      let authResult: any;\n      await act(async () => {\n        authResult = await result.current.generateAuthUrl();\n      });\n\n      expect(mockPKCEAdapter.generateCodeChallenge).toHaveBeenCalledTimes(1);\n      expect(mockPKCEAdapter.generateState).toHaveBeenCalledTimes(1);\n\n      expect(authResult).toEqual({\n        authUrl: expect.stringContaining('https://auth.example.com/authorize'),\n        codeVerifier: 'test-verifier',\n        state: 'test-state',\n      });\n\n      // Verify URL parameters\n      const url = new URL(authResult.authUrl);\n      expect(url.searchParams.get('response_type')).toBe('code');\n      expect(url.searchParams.get('client_id')).toBe('test-client-id');\n      expect(url.searchParams.get('redirect_uri')).toBe(\n        'myapp://oauth/callback'\n      );\n      expect(url.searchParams.get('scope')).toBe('read write');\n      expect(url.searchParams.get('state')).toBe('test-state');\n      expect(url.searchParams.get('code_challenge')).toBe('test-challenge');\n      expect(url.searchParams.get('code_challenge_method')).toBe('S256');\n    });\n\n    it('should include additional parameters in authorization URL', async () => {\n      const mockChallenge = {\n        codeChallenge: 'test-challenge',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'test-verifier',\n      };\n      const mockState = 'test-state';\n\n      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read', 'write'],\n          additionalParameters: {\n            audience: 'https://api.example.com',\n            prompt: 'consent',\n            access_type: 'offline',\n          },\n        })\n      );\n\n      let authResult: any;\n      await act(async () => {\n        authResult = await result.current.generateAuthUrl();\n      });\n\n      const url = new URL(authResult.authUrl);\n      expect(url.searchParams.get('audience')).toBe('https://api.example.com');\n      expect(url.searchParams.get('prompt')).toBe('consent');\n      expect(url.searchParams.get('access_type')).toBe('offline');\n    });\n\n    it('should handle PKCE generation errors', async () => {\n      mockPKCEAdapter.generateCodeChallenge.mockRejectedValue(\n        new Error('PKCE generation failed')\n      );\n\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read'],\n        })\n      );\n\n      await act(async () => {\n        await expect(result.current.generateAuthUrl()).rejects.toThrow(\n          'PKCE generation failed'\n        );\n      });\n    });\n\n    it('should handle state generation errors', async () => {\n      const mockChallenge = {\n        codeChallenge: 'test-challenge',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'test-verifier',\n      };\n\n      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n      mockPKCEAdapter.generateState.mockRejectedValue(\n        new Error('State generation failed')\n      );\n\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read'],\n        })\n      );\n\n      await act(async () => {\n        await expect(result.current.generateAuthUrl()).rejects.toThrow(\n          'State generation failed'\n        );\n      });\n    });\n  });\n\n  describe('edge cases', () => {\n    it('should handle empty scopes array', () => {\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: [],\n        })\n      );\n\n      expect(result.current.config.scopes).toEqual([]);\n    });\n\n    it('should handle single scope', async () => {\n      const mockChallenge = {\n        codeChallenge: 'test-challenge',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'test-verifier',\n      };\n      const mockState = 'test-state';\n\n      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read'],\n        })\n      );\n\n      let authResult: any;\n      await act(async () => {\n        authResult = await result.current.generateAuthUrl();\n      });\n\n      const url = new URL(authResult.authUrl);\n      expect(url.searchParams.get('scope')).toBe('read');\n    });\n\n    it('should handle special characters in parameters', async () => {\n      const mockChallenge = {\n        codeChallenge: 'test-challenge',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'test-verifier',\n      };\n      const mockState = 'test-state-with-special-chars!@#$%';\n\n      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n\n      const { result } = renderHook(() =>\n        useOAuthConfig({\n          clientId: 'test-client-id',\n          authorizationEndpoint: 'https://auth.example.com/authorize',\n          tokenEndpoint: 'https://auth.example.com/token',\n          redirectUri: 'myapp://oauth/callback',\n          scopes: ['read', 'write:special-scope'],\n          additionalParameters: {\n            custom_param: 'value with spaces & symbols',\n          },\n        })\n      );\n\n      let authResult: any;\n      await act(async () => {\n        authResult = await result.current.generateAuthUrl();\n      });\n\n      const url = new URL(authResult.authUrl);\n      expect(url.searchParams.get('state')).toBe(\n        'test-state-with-special-chars!@#$%'\n      );\n      expect(url.searchParams.get('scope')).toBe('read write:special-scope');\n      expect(url.searchParams.get('custom_param')).toBe(\n        'value with spaces & symbols'\n      );\n    });\n  });\n\n  describe('config updates', () => {\n    it('should update config when options change', () => {\n      const { result, rerender } = renderHook(\n        ({ clientId }) =>\n          useOAuthConfig({\n            clientId,\n            authorizationEndpoint: 'https://auth.example.com/authorize',\n            tokenEndpoint: 'https://auth.example.com/token',\n            redirectUri: 'myapp://oauth/callback',\n            scopes: ['read'],\n          }),\n        {\n          initialProps: { clientId: 'client-1' },\n        }\n      );\n\n      expect(result.current.config.clientId).toBe('client-1');\n\n      rerender({ clientId: 'client-2' });\n\n      expect(result.current.config.clientId).toBe('client-2');\n    });\n  });\n});\n"
        }
    ]
}