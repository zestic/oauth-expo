{
    "sourceFile": "src/__tests__/ExpoOAuthAdapter.test.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1752917291502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752917313728,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,8 +43,11 @@\n \n     // Create mock instances\n     mockOAuthCore = {\n       handleCallback: jest.fn(),\n+      generateAuthorizationUrl: jest.fn(),\n+      generatePKCEChallenge: jest.fn(),\n+      generateState: jest.fn(),\n     } as any;\n \n     mockStorageAdapter = {\n       setItem: jest.fn(),\n"
                },
                {
                    "date": 1752917335755,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,55 +191,49 @@\n     });\n   });\n \n   describe('generatePKCEParams', () => {\n-    it('should generate and store PKCE parameters', async () => {\n+    it('should delegate to OAuthCore for PKCE generation', async () => {\n       const mockChallenge = {\n         codeChallenge: 'challenge-123',\n         codeChallengeMethod: 'S256',\n         codeVerifier: 'verifier-456',\n       };\n       const mockState = 'state-789';\n \n-      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n-      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n-      mockStorageAdapter.setItem.mockResolvedValue();\n+      mockOAuthCore.generatePKCEChallenge.mockResolvedValue(mockChallenge);\n+      mockOAuthCore.generateState.mockResolvedValue(mockState);\n \n       const result = await adapter.generatePKCEParams();\n \n-      expect(mockPKCEAdapter.generateCodeChallenge).toHaveBeenCalledTimes(1);\n-      expect(mockPKCEAdapter.generateState).toHaveBeenCalledTimes(1);\n+      expect(mockOAuthCore.generatePKCEChallenge).toHaveBeenCalledTimes(1);\n+      expect(mockOAuthCore.generateState).toHaveBeenCalledTimes(1);\n \n-      expect(mockStorageAdapter.setItem).toHaveBeenCalledWith('oauth_code_verifier', 'verifier-456');\n-      expect(mockStorageAdapter.setItem).toHaveBeenCalledWith('oauth_state', 'state-789');\n-\n       expect(result).toEqual({\n         codeChallenge: 'challenge-123',\n         codeChallengeMethod: 'S256',\n         codeVerifier: 'verifier-456',\n         state: 'state-789',\n       });\n     });\n \n-    it('should handle PKCE generation errors', async () => {\n-      mockPKCEAdapter.generateCodeChallenge.mockRejectedValue(new Error('PKCE generation failed'));\n+    it('should handle PKCE generation errors from OAuthCore', async () => {\n+      mockOAuthCore.generatePKCEChallenge.mockRejectedValue(new Error('PKCE generation failed'));\n \n       await expect(adapter.generatePKCEParams()).rejects.toThrow('PKCE generation failed');\n     });\n \n-    it('should handle storage errors', async () => {\n+    it('should handle state generation errors from OAuthCore', async () => {\n       const mockChallenge = {\n         codeChallenge: 'challenge-123',\n         codeChallengeMethod: 'S256',\n         codeVerifier: 'verifier-456',\n       };\n-      const mockState = 'state-789';\n \n-      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n-      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n-      mockStorageAdapter.setItem.mockRejectedValue(new Error('Storage failed'));\n+      mockOAuthCore.generatePKCEChallenge.mockResolvedValue(mockChallenge);\n+      mockOAuthCore.generateState.mockRejectedValue(new Error('State generation failed'));\n \n-      await expect(adapter.generatePKCEParams()).rejects.toThrow('Storage failed');\n+      await expect(adapter.generatePKCEParams()).rejects.toThrow('State generation failed');\n     });\n   });\n \n   describe('generateAuthorizationUrl', () => {\n"
                },
                {
                    "date": 1752931803238,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -292,14 +292,10 @@\n   });\n \n   describe('isAuthenticated', () => {\n     it('should return true when tokens exist and are not expired', async () => {\n-      mockStorageAdapter.getTokens.mockResolvedValue({\n-        accessToken: 'token-123',\n-        refreshToken: 'refresh-456',\n-        expiresAt: Date.now() + 3600000,\n-      });\n-      mockStorageAdapter.isTokenExpired.mockResolvedValue(false);\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(false);\n \n       const result = await adapter.isAuthenticated();\n \n       expect(result).toBe(true);\n"
                },
                {
                    "date": 1752931812178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -301,13 +301,9 @@\n       expect(result).toBe(true);\n     });\n \n     it('should return false when no access token exists', async () => {\n-      mockStorageAdapter.getTokens.mockResolvedValue({\n-        accessToken: null,\n-        refreshToken: null,\n-        expiresAt: null,\n-      });\n+      mockOAuthCore.getAccessToken.mockResolvedValue(null);\n \n       const result = await adapter.isAuthenticated();\n \n       expect(result).toBe(false);\n"
                },
                {
                    "date": 1752931841058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -309,14 +309,10 @@\n       expect(result).toBe(false);\n     });\n \n     it('should return false when token is expired', async () => {\n-      mockStorageAdapter.getTokens.mockResolvedValue({\n-        accessToken: 'token-123',\n-        refreshToken: 'refresh-456',\n-        expiresAt: Date.now() - 1000,\n-      });\n-      mockStorageAdapter.isTokenExpired.mockResolvedValue(true);\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(true);\n \n       const result = await adapter.isAuthenticated();\n \n       expect(result).toBe(false);\n"
                },
                {
                    "date": 1752931851017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -320,14 +320,10 @@\n   });\n \n   describe('getAccessToken', () => {\n     it('should return access token when valid', async () => {\n-      mockStorageAdapter.getTokens.mockResolvedValue({\n-        accessToken: 'token-123',\n-        refreshToken: 'refresh-456',\n-        expiresAt: Date.now() + 3600000,\n-      });\n-      mockStorageAdapter.isTokenExpired.mockResolvedValue(false);\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(false);\n \n       const result = await adapter.getAccessToken();\n \n       expect(result).toBe('token-123');\n"
                },
                {
                    "date": 1752931872105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -329,14 +329,10 @@\n       expect(result).toBe('token-123');\n     });\n \n     it('should logout and return null when token is expired', async () => {\n-      mockStorageAdapter.getTokens.mockResolvedValue({\n-        accessToken: 'token-123',\n-        refreshToken: 'refresh-456',\n-        expiresAt: Date.now() - 1000,\n-      });\n-      mockStorageAdapter.isTokenExpired.mockResolvedValue(true);\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(true);\n       mockStorageAdapter.clearOAuthStorage.mockResolvedValue();\n \n       const result = await adapter.getAccessToken();\n \n"
                },
                {
                    "date": 1752998372736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,361 @@\n+import { OAuthCore } from '@zestic/oauth-core';\n+import { ExpoOAuthAdapter } from '../ExpoOAuthAdapter';\n+import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../adapters';\n+import type { ExpoOAuthConfig, OAuthCallbackParams } from '../types';\n+\n+// Mock the adapters\n+jest.mock('../adapters/ExpoStorageAdapter');\n+jest.mock('../adapters/ExpoHttpAdapter');\n+jest.mock('../adapters/ExpoPKCEAdapter');\n+\n+// Mock OAuthCore\n+jest.mock('@zestic/oauth-core', () => ({\n+  OAuthCore: jest.fn(),\n+}));\n+\n+const MockedOAuthCore = OAuthCore as jest.MockedClass<typeof OAuthCore>;\n+const MockedExpoStorageAdapter = ExpoStorageAdapter as jest.MockedClass<typeof ExpoStorageAdapter>;\n+const MockedExpoHttpAdapter = ExpoHttpAdapter as jest.MockedClass<typeof ExpoHttpAdapter>;\n+const MockedExpoPKCEAdapter = ExpoPKCEAdapter as jest.MockedClass<typeof ExpoPKCEAdapter>;\n+\n+describe('ExpoOAuthAdapter', () => {\n+  let adapter: ExpoOAuthAdapter;\n+  let mockOAuthCore: jest.Mocked<OAuthCore>;\n+  let mockStorageAdapter: jest.Mocked<ExpoStorageAdapter>;\n+  let mockHttpAdapter: jest.Mocked<ExpoHttpAdapter>;\n+  let mockPKCEAdapter: jest.Mocked<ExpoPKCEAdapter>;\n+\n+  const mockConfig: ExpoOAuthConfig = {\n+    clientId: 'test-client-id',\n+    endpoints: {\n+      authorization: 'https://auth.example.com/authorize',\n+      token: 'https://auth.example.com/token',\n+    },\n+    redirectUri: 'myapp://oauth/callback',\n+    scopes: ['read', 'write'],\n+    scheme: 'myapp',\n+    path: '/oauth/callback',\n+  };\n+\n+  beforeEach(() => {\n+    // Reset all mocks\n+    jest.clearAllMocks();\n+\n+    // Create mock instances\n+    mockOAuthCore = {\n+      handleCallback: jest.fn(),\n+      generateAuthorizationUrl: jest.fn(),\n+      generatePKCEChallenge: jest.fn(),\n+      generateState: jest.fn(),\n+      getAccessToken: jest.fn(),\n+      isTokenExpired: jest.fn(),\n+    } as any;\n+\n+    mockStorageAdapter = {\n+      setItem: jest.fn(),\n+      getItem: jest.fn(),\n+      removeItem: jest.fn(),\n+      removeItems: jest.fn(),\n+      clearOAuthStorage: jest.fn(),\n+      storeTokens: jest.fn(),\n+      getTokens: jest.fn(),\n+      isTokenExpired: jest.fn(),\n+    } as any;\n+\n+    mockHttpAdapter = {\n+      post: jest.fn(),\n+      get: jest.fn(),\n+    } as any;\n+\n+    mockPKCEAdapter = {\n+      generateCodeChallenge: jest.fn(),\n+      generateState: jest.fn(),\n+    } as any;\n+\n+    // Setup constructor mocks\n+    MockedOAuthCore.mockImplementation(() => mockOAuthCore);\n+    MockedExpoStorageAdapter.mockImplementation(() => mockStorageAdapter);\n+    MockedExpoHttpAdapter.mockImplementation(() => mockHttpAdapter);\n+    MockedExpoPKCEAdapter.mockImplementation(() => mockPKCEAdapter);\n+\n+    adapter = new ExpoOAuthAdapter(mockConfig);\n+  });\n+\n+  describe('constructor', () => {\n+    it('should initialize with correct adapters', () => {\n+      expect(MockedExpoStorageAdapter).toHaveBeenCalledTimes(1);\n+      expect(MockedExpoHttpAdapter).toHaveBeenCalledTimes(1);\n+      expect(MockedExpoPKCEAdapter).toHaveBeenCalledTimes(1);\n+    });\n+\n+    it('should initialize OAuthCore with config and adapters', () => {\n+      expect(MockedOAuthCore).toHaveBeenCalledWith(\n+        mockConfig,\n+        {\n+          storage: mockStorageAdapter,\n+          http: mockHttpAdapter,\n+          pkce: mockPKCEAdapter,\n+        },\n+        mockConfig.flows\n+      );\n+    });\n+  });\n+\n+  describe('handleCallback', () => {\n+    it('should convert params to URLSearchParams and call OAuthCore', async () => {\n+      const callbackParams: OAuthCallbackParams = {\n+        code: 'auth-code-123',\n+        state: 'state-456',\n+      };\n+\n+      const expectedResult = {\n+        success: true,\n+        tokens: { accessToken: 'token-123' },\n+      };\n+\n+      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n+\n+      const result = await adapter.handleCallback(callbackParams);\n+\n+      expect(mockOAuthCore.handleCallback).toHaveBeenCalledWith(\n+        expect.any(URLSearchParams)\n+      );\n+\n+      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n+      expect(urlParams.get('code')).toBe('auth-code-123');\n+      expect(urlParams.get('state')).toBe('state-456');\n+\n+      expect(result).toBe(expectedResult);\n+    });\n+\n+    it('should handle magic link callback params', async () => {\n+      const callbackParams: OAuthCallbackParams = {\n+        token: 'magic-link-token',\n+        magic_link_token: 'magic-token-123',\n+        flow: 'magic_link',\n+      };\n+\n+      const expectedResult = {\n+        success: true,\n+        tokens: { accessToken: 'token-456' },\n+      };\n+\n+      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n+\n+      const result = await adapter.handleCallback(callbackParams);\n+\n+      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n+      expect(urlParams.get('token')).toBe('magic-link-token');\n+      expect(urlParams.get('magic_link_token')).toBe('magic-token-123');\n+      expect(urlParams.get('flow')).toBe('magic_link');\n+\n+      expect(result).toBe(expectedResult);\n+    });\n+\n+    it('should handle error callback params', async () => {\n+      const callbackParams: OAuthCallbackParams = {\n+        error: 'access_denied',\n+        error_description: 'User denied access',\n+      };\n+\n+      const expectedResult = {\n+        success: false,\n+        error: 'access_denied',\n+        message: 'User denied access',\n+      };\n+\n+      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n+\n+      const result = await adapter.handleCallback(callbackParams);\n+\n+      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n+      expect(urlParams.get('error')).toBe('access_denied');\n+      expect(urlParams.get('error_description')).toBe('User denied access');\n+\n+      expect(result).toBe(expectedResult);\n+    });\n+\n+    it('should filter out null and undefined values', async () => {\n+      const callbackParams: OAuthCallbackParams = {\n+        code: 'auth-code-123',\n+        state: null,\n+        error: undefined,\n+      };\n+\n+      mockOAuthCore.handleCallback.mockResolvedValue({ success: true } as any);\n+\n+      await adapter.handleCallback(callbackParams);\n+\n+      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n+      expect(urlParams.get('code')).toBe('auth-code-123');\n+      expect(urlParams.has('state')).toBe(false);\n+      expect(urlParams.has('error')).toBe(false);\n+    });\n+  });\n+\n+  describe('generatePKCEParams', () => {\n+    it('should delegate to OAuthCore for PKCE generation', async () => {\n+      const mockChallenge = {\n+        codeChallenge: 'challenge-123',\n+        codeChallengeMethod: 'S256',\n+        codeVerifier: 'verifier-456',\n+      };\n+      const mockState = 'state-789';\n+\n+      mockOAuthCore.generatePKCEChallenge.mockResolvedValue(mockChallenge);\n+      mockOAuthCore.generateState.mockResolvedValue(mockState);\n+\n+      const result = await adapter.generatePKCEParams();\n+\n+      expect(mockOAuthCore.generatePKCEChallenge).toHaveBeenCalledTimes(1);\n+      expect(mockOAuthCore.generateState).toHaveBeenCalledTimes(1);\n+\n+      expect(result).toEqual({\n+        codeChallenge: 'challenge-123',\n+        codeChallengeMethod: 'S256',\n+        codeVerifier: 'verifier-456',\n+        state: 'state-789',\n+      });\n+    });\n+\n+    it('should handle PKCE generation errors from OAuthCore', async () => {\n+      mockOAuthCore.generatePKCEChallenge.mockRejectedValue(new Error('PKCE generation failed'));\n+\n+      await expect(adapter.generatePKCEParams()).rejects.toThrow('PKCE generation failed');\n+    });\n+\n+    it('should handle state generation errors from OAuthCore', async () => {\n+      const mockChallenge = {\n+        codeChallenge: 'challenge-123',\n+        codeChallengeMethod: 'S256',\n+        codeVerifier: 'verifier-456',\n+      };\n+\n+      mockOAuthCore.generatePKCEChallenge.mockResolvedValue(mockChallenge);\n+      mockOAuthCore.generateState.mockRejectedValue(new Error('State generation failed'));\n+\n+      await expect(adapter.generatePKCEParams()).rejects.toThrow('State generation failed');\n+    });\n+  });\n+\n+  describe('generateAuthorizationUrl', () => {\n+    it('should delegate to OAuthCore and return authorization URL', async () => {\n+      const mockResult = {\n+        url: 'https://auth.example.com/oauth/authorize?client_id=test-client&response_type=code&state=test-state',\n+        state: 'test-state-789',\n+      };\n+\n+      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n+\n+      const result = await adapter.generateAuthorizationUrl();\n+\n+      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith(undefined);\n+      expect(result).toEqual(mockResult);\n+    });\n+\n+    it('should pass additional parameters to OAuthCore', async () => {\n+      const additionalParams = {\n+        audience: 'https://api.example.com',\n+        prompt: 'consent',\n+      };\n+\n+      const mockResult = {\n+        url: 'https://auth.example.com/oauth/authorize?client_id=test-client&audience=https://api.example.com',\n+        state: 'test-state-789',\n+      };\n+\n+      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n+\n+      const result = await adapter.generateAuthorizationUrl(additionalParams);\n+\n+      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith(additionalParams);\n+      expect(result).toEqual(mockResult);\n+    });\n+\n+    it('should handle OAuthCore errors', async () => {\n+      mockOAuthCore.generateAuthorizationUrl.mockRejectedValue(new Error('URL generation failed'));\n+\n+      await expect(adapter.generateAuthorizationUrl()).rejects.toThrow('URL generation failed');\n+    });\n+\n+    it('should handle empty additional parameters', async () => {\n+      const mockResult = {\n+        url: 'https://auth.example.com/oauth/authorize?client_id=test-client',\n+        state: 'test-state-789',\n+      };\n+\n+      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n+\n+      const result = await adapter.generateAuthorizationUrl({});\n+\n+      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith({});\n+      expect(result).toEqual(mockResult);\n+    });\n+  });\n+\n+  describe('isAuthenticated', () => {\n+    it('should return true when tokens exist and are not expired', async () => {\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(false);\n+\n+      const result = await adapter.isAuthenticated();\n+\n+      expect(result).toBe(true);\n+    });\n+\n+    it('should return false when no access token exists', async () => {\n+      mockOAuthCore.getAccessToken.mockResolvedValue(null);\n+\n+      const result = await adapter.isAuthenticated();\n+\n+      expect(result).toBe(false);\n+    });\n+\n+    it('should return false when token is expired', async () => {\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(true);\n+\n+      const result = await adapter.isAuthenticated();\n+\n+      expect(result).toBe(false);\n+    });\n+  });\n+\n+  describe('getAccessToken', () => {\n+    it('should return access token when valid', async () => {\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(false);\n+\n+      const result = await adapter.getAccessToken();\n+\n+      expect(result).toBe('token-123');\n+    });\n+\n+    it('should logout and return null when token is expired', async () => {\n+      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n+      mockOAuthCore.isTokenExpired.mockResolvedValue(true);\n+      mockStorageAdapter.clearOAuthStorage.mockResolvedValue();\n+\n+      const result = await adapter.getAccessToken();\n+\n+      expect(mockStorageAdapter.clearOAuthStorage).toHaveBeenCalledTimes(1);\n+      expect(result).toBeNull();\n+    });\n+  });\n+\n+  describe('logout', () => {\n+    it('should clear OAuth storage', async () => {\n+      mockStorageAdapter.clearOAuthStorage.mockResolvedValue();\n+\n+      await adapter.logout();\n+\n+      expect(mockStorageAdapter.clearOAuthStorage).toHaveBeenCalledTimes(1);\n+    });\n+\n+    it('should handle storage errors during logout', async () => {\n+      mockStorageAdapter.clearOAuthStorage.mockRejectedValue(new Error('Clear storage failed'));\n+\n+      await expect(adapter.logout()).rejects.toThrow('Clear storage failed');\n+    });\n+  });\n+});\n"
                },
                {
                    "date": 1752998399743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,8 +34,9 @@\n     redirectUri: 'myapp://oauth/callback',\n     scopes: ['read', 'write'],\n     scheme: 'myapp',\n     path: '/oauth/callback',\n+    flows: ['authorization_code', 'magic_link'],\n   };\n \n   beforeEach(() => {\n     // Reset all mocks\n@@ -358,363 +359,4 @@\n       await expect(adapter.logout()).rejects.toThrow('Clear storage failed');\n     });\n   });\n });\n-import { OAuthCore } from '@zestic/oauth-core';\n-import { ExpoOAuthAdapter } from '../ExpoOAuthAdapter';\n-import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../adapters';\n-import type { ExpoOAuthConfig, OAuthCallbackParams } from '../types';\n-\n-// Mock the adapters\n-jest.mock('../adapters/ExpoStorageAdapter');\n-jest.mock('../adapters/ExpoHttpAdapter');\n-jest.mock('../adapters/ExpoPKCEAdapter');\n-\n-// Mock OAuthCore\n-jest.mock('@zestic/oauth-core', () => ({\n-  OAuthCore: jest.fn(),\n-}));\n-\n-const MockedOAuthCore = OAuthCore as jest.MockedClass<typeof OAuthCore>;\n-const MockedExpoStorageAdapter = ExpoStorageAdapter as jest.MockedClass<typeof ExpoStorageAdapter>;\n-const MockedExpoHttpAdapter = ExpoHttpAdapter as jest.MockedClass<typeof ExpoHttpAdapter>;\n-const MockedExpoPKCEAdapter = ExpoPKCEAdapter as jest.MockedClass<typeof ExpoPKCEAdapter>;\n-\n-describe('ExpoOAuthAdapter', () => {\n-  let adapter: ExpoOAuthAdapter;\n-  let mockOAuthCore: jest.Mocked<OAuthCore>;\n-  let mockStorageAdapter: jest.Mocked<ExpoStorageAdapter>;\n-  let mockHttpAdapter: jest.Mocked<ExpoHttpAdapter>;\n-  let mockPKCEAdapter: jest.Mocked<ExpoPKCEAdapter>;\n-\n-  const mockConfig: ExpoOAuthConfig = {\n-    clientId: 'test-client-id',\n-    endpoints: {\n-      authorization: 'https://auth.example.com/authorize',\n-      token: 'https://auth.example.com/token',\n-    },\n-    redirectUri: 'myapp://oauth/callback',\n-    scopes: ['read', 'write'],\n-    scheme: 'myapp',\n-    path: '/oauth/callback',\n-  };\n-\n-  beforeEach(() => {\n-    // Reset all mocks\n-    jest.clearAllMocks();\n-\n-    // Create mock instances\n-    mockOAuthCore = {\n-      handleCallback: jest.fn(),\n-      generateAuthorizationUrl: jest.fn(),\n-      generatePKCEChallenge: jest.fn(),\n-      generateState: jest.fn(),\n-    } as any;\n-\n-    mockStorageAdapter = {\n-      setItem: jest.fn(),\n-      getItem: jest.fn(),\n-      removeItem: jest.fn(),\n-      removeItems: jest.fn(),\n-      clearOAuthStorage: jest.fn(),\n-      storeTokens: jest.fn(),\n-      getTokens: jest.fn(),\n-      isTokenExpired: jest.fn(),\n-    } as any;\n-\n-    mockHttpAdapter = {\n-      post: jest.fn(),\n-      get: jest.fn(),\n-    } as any;\n-\n-    mockPKCEAdapter = {\n-      generateCodeChallenge: jest.fn(),\n-      generateState: jest.fn(),\n-    } as any;\n-\n-    // Setup constructor mocks\n-    MockedOAuthCore.mockImplementation(() => mockOAuthCore);\n-    MockedExpoStorageAdapter.mockImplementation(() => mockStorageAdapter);\n-    MockedExpoHttpAdapter.mockImplementation(() => mockHttpAdapter);\n-    MockedExpoPKCEAdapter.mockImplementation(() => mockPKCEAdapter);\n-\n-    adapter = new ExpoOAuthAdapter(mockConfig);\n-  });\n-\n-  describe('constructor', () => {\n-    it('should initialize with correct adapters', () => {\n-      expect(MockedExpoStorageAdapter).toHaveBeenCalledTimes(1);\n-      expect(MockedExpoHttpAdapter).toHaveBeenCalledTimes(1);\n-      expect(MockedExpoPKCEAdapter).toHaveBeenCalledTimes(1);\n-    });\n-\n-    it('should initialize OAuthCore with config and adapters', () => {\n-      expect(MockedOAuthCore).toHaveBeenCalledWith(\n-        mockConfig,\n-        {\n-          storage: mockStorageAdapter,\n-          http: mockHttpAdapter,\n-          pkce: mockPKCEAdapter,\n-        },\n-        mockConfig.flows\n-      );\n-    });\n-  });\n-\n-  describe('handleCallback', () => {\n-    it('should convert params to URLSearchParams and call OAuthCore', async () => {\n-      const callbackParams: OAuthCallbackParams = {\n-        code: 'auth-code-123',\n-        state: 'state-456',\n-      };\n-\n-      const expectedResult = {\n-        success: true,\n-        tokens: { accessToken: 'token-123' },\n-      };\n-\n-      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n-\n-      const result = await adapter.handleCallback(callbackParams);\n-\n-      expect(mockOAuthCore.handleCallback).toHaveBeenCalledWith(\n-        expect.any(URLSearchParams)\n-      );\n-\n-      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n-      expect(urlParams.get('code')).toBe('auth-code-123');\n-      expect(urlParams.get('state')).toBe('state-456');\n-\n-      expect(result).toBe(expectedResult);\n-    });\n-\n-    it('should handle magic link callback params', async () => {\n-      const callbackParams: OAuthCallbackParams = {\n-        token: 'magic-link-token',\n-        magic_link_token: 'magic-token-123',\n-        flow: 'magic_link',\n-      };\n-\n-      const expectedResult = {\n-        success: true,\n-        tokens: { accessToken: 'token-456' },\n-      };\n-\n-      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n-\n-      const result = await adapter.handleCallback(callbackParams);\n-\n-      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n-      expect(urlParams.get('token')).toBe('magic-link-token');\n-      expect(urlParams.get('magic_link_token')).toBe('magic-token-123');\n-      expect(urlParams.get('flow')).toBe('magic_link');\n-\n-      expect(result).toBe(expectedResult);\n-    });\n-\n-    it('should handle error callback params', async () => {\n-      const callbackParams: OAuthCallbackParams = {\n-        error: 'access_denied',\n-        error_description: 'User denied access',\n-      };\n-\n-      const expectedResult = {\n-        success: false,\n-        error: 'access_denied',\n-        message: 'User denied access',\n-      };\n-\n-      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n-\n-      const result = await adapter.handleCallback(callbackParams);\n-\n-      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n-      expect(urlParams.get('error')).toBe('access_denied');\n-      expect(urlParams.get('error_description')).toBe('User denied access');\n-\n-      expect(result).toBe(expectedResult);\n-    });\n-\n-    it('should filter out null and undefined values', async () => {\n-      const callbackParams: OAuthCallbackParams = {\n-        code: 'auth-code-123',\n-        state: null,\n-        error: undefined,\n-      };\n-\n-      mockOAuthCore.handleCallback.mockResolvedValue({ success: true } as any);\n-\n-      await adapter.handleCallback(callbackParams);\n-\n-      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n-      expect(urlParams.get('code')).toBe('auth-code-123');\n-      expect(urlParams.has('state')).toBe(false);\n-      expect(urlParams.has('error')).toBe(false);\n-    });\n-  });\n-\n-  describe('generatePKCEParams', () => {\n-    it('should delegate to OAuthCore for PKCE generation', async () => {\n-      const mockChallenge = {\n-        codeChallenge: 'challenge-123',\n-        codeChallengeMethod: 'S256',\n-        codeVerifier: 'verifier-456',\n-      };\n-      const mockState = 'state-789';\n-\n-      mockOAuthCore.generatePKCEChallenge.mockResolvedValue(mockChallenge);\n-      mockOAuthCore.generateState.mockResolvedValue(mockState);\n-\n-      const result = await adapter.generatePKCEParams();\n-\n-      expect(mockOAuthCore.generatePKCEChallenge).toHaveBeenCalledTimes(1);\n-      expect(mockOAuthCore.generateState).toHaveBeenCalledTimes(1);\n-\n-      expect(result).toEqual({\n-        codeChallenge: 'challenge-123',\n-        codeChallengeMethod: 'S256',\n-        codeVerifier: 'verifier-456',\n-        state: 'state-789',\n-      });\n-    });\n-\n-    it('should handle PKCE generation errors from OAuthCore', async () => {\n-      mockOAuthCore.generatePKCEChallenge.mockRejectedValue(new Error('PKCE generation failed'));\n-\n-      await expect(adapter.generatePKCEParams()).rejects.toThrow('PKCE generation failed');\n-    });\n-\n-    it('should handle state generation errors from OAuthCore', async () => {\n-      const mockChallenge = {\n-        codeChallenge: 'challenge-123',\n-        codeChallengeMethod: 'S256',\n-        codeVerifier: 'verifier-456',\n-      };\n-\n-      mockOAuthCore.generatePKCEChallenge.mockResolvedValue(mockChallenge);\n-      mockOAuthCore.generateState.mockRejectedValue(new Error('State generation failed'));\n-\n-      await expect(adapter.generatePKCEParams()).rejects.toThrow('State generation failed');\n-    });\n-  });\n-\n-  describe('generateAuthorizationUrl', () => {\n-    it('should delegate to OAuthCore and return authorization URL', async () => {\n-      const mockResult = {\n-        url: 'https://auth.example.com/oauth/authorize?client_id=test-client&response_type=code&state=test-state',\n-        state: 'test-state-789',\n-      };\n-\n-      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n-\n-      const result = await adapter.generateAuthorizationUrl();\n-\n-      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith(undefined);\n-      expect(result).toEqual(mockResult);\n-    });\n-\n-    it('should pass additional parameters to OAuthCore', async () => {\n-      const additionalParams = {\n-        audience: 'https://api.example.com',\n-        prompt: 'consent',\n-      };\n-\n-      const mockResult = {\n-        url: 'https://auth.example.com/oauth/authorize?client_id=test-client&audience=https://api.example.com',\n-        state: 'test-state-789',\n-      };\n-\n-      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n-\n-      const result = await adapter.generateAuthorizationUrl(additionalParams);\n-\n-      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith(additionalParams);\n-      expect(result).toEqual(mockResult);\n-    });\n-\n-    it('should handle OAuthCore errors', async () => {\n-      mockOAuthCore.generateAuthorizationUrl.mockRejectedValue(new Error('URL generation failed'));\n-\n-      await expect(adapter.generateAuthorizationUrl()).rejects.toThrow('URL generation failed');\n-    });\n-\n-    it('should handle empty additional parameters', async () => {\n-      const mockResult = {\n-        url: 'https://auth.example.com/oauth/authorize?client_id=test-client',\n-        state: 'test-state-789',\n-      };\n-\n-      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n-\n-      const result = await adapter.generateAuthorizationUrl({});\n-\n-      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith({});\n-      expect(result).toEqual(mockResult);\n-    });\n-  });\n-\n-  describe('isAuthenticated', () => {\n-    it('should return true when tokens exist and are not expired', async () => {\n-      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n-      mockOAuthCore.isTokenExpired.mockResolvedValue(false);\n-\n-      const result = await adapter.isAuthenticated();\n-\n-      expect(result).toBe(true);\n-    });\n-\n-    it('should return false when no access token exists', async () => {\n-      mockOAuthCore.getAccessToken.mockResolvedValue(null);\n-\n-      const result = await adapter.isAuthenticated();\n-\n-      expect(result).toBe(false);\n-    });\n-\n-    it('should return false when token is expired', async () => {\n-      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n-      mockOAuthCore.isTokenExpired.mockResolvedValue(true);\n-\n-      const result = await adapter.isAuthenticated();\n-\n-      expect(result).toBe(false);\n-    });\n-  });\n-\n-  describe('getAccessToken', () => {\n-    it('should return access token when valid', async () => {\n-      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n-      mockOAuthCore.isTokenExpired.mockResolvedValue(false);\n-\n-      const result = await adapter.getAccessToken();\n-\n-      expect(result).toBe('token-123');\n-    });\n-\n-    it('should logout and return null when token is expired', async () => {\n-      mockOAuthCore.getAccessToken.mockResolvedValue('token-123');\n-      mockOAuthCore.isTokenExpired.mockResolvedValue(true);\n-      mockStorageAdapter.clearOAuthStorage.mockResolvedValue();\n-\n-      const result = await adapter.getAccessToken();\n-\n-      expect(mockStorageAdapter.clearOAuthStorage).toHaveBeenCalledTimes(1);\n-      expect(result).toBeNull();\n-    });\n-  });\n-\n-  describe('logout', () => {\n-    it('should clear OAuth storage', async () => {\n-      mockStorageAdapter.clearOAuthStorage.mockResolvedValue();\n-\n-      await adapter.logout();\n-\n-      expect(mockStorageAdapter.clearOAuthStorage).toHaveBeenCalledTimes(1);\n-    });\n-\n-    it('should handle storage errors during logout', async () => {\n-      mockStorageAdapter.clearOAuthStorage.mockRejectedValue(new Error('Clear storage failed'));\n-\n-      await expect(adapter.logout()).rejects.toThrow('Clear storage failed');\n-    });\n-  });\n-});\n"
                },
                {
                    "date": 1752998443927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,8 @@\n     redirectUri: 'myapp://oauth/callback',\n     scopes: ['read', 'write'],\n     scheme: 'myapp',\n     path: '/oauth/callback',\n-    flows: ['authorization_code', 'magic_link'],\n   };\n \n   beforeEach(() => {\n     // Reset all mocks\n"
                },
                {
                    "date": 1752998451820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,9 +95,9 @@\n           storage: mockStorageAdapter,\n           http: mockHttpAdapter,\n           pkce: mockPKCEAdapter,\n         },\n-        mockConfig.flows\n+        undefined\n       );\n     });\n   });\n \n"
                },
                {
                    "date": 1752998458919,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n       expect(mockOAuthCore.handleCallback).toHaveBeenCalledWith(\n         expect.any(URLSearchParams)\n       );\n \n-      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n+      const urlParams = mockOAuthCore.handleCallback.mock.calls[0]?.[0] as URLSearchParams;\n       expect(urlParams.get('code')).toBe('auth-code-123');\n       expect(urlParams.get('state')).toBe('state-456');\n \n       expect(result).toBe(expectedResult);\n"
                },
                {
                    "date": 1752998466386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,9 +143,9 @@\n       mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n \n       const result = await adapter.handleCallback(callbackParams);\n \n-      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n+      const urlParams = mockOAuthCore.handleCallback.mock.calls[0]?.[0] as URLSearchParams;\n       expect(urlParams.get('token')).toBe('magic-link-token');\n       expect(urlParams.get('magic_link_token')).toBe('magic-token-123');\n       expect(urlParams.get('flow')).toBe('magic_link');\n \n"
                },
                {
                    "date": 1752998473163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,9 +167,9 @@\n       mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n \n       const result = await adapter.handleCallback(callbackParams);\n \n-      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n+      const urlParams = mockOAuthCore.handleCallback.mock.calls[0]?.[0] as URLSearchParams;\n       expect(urlParams.get('error')).toBe('access_denied');\n       expect(urlParams.get('error_description')).toBe('User denied access');\n \n       expect(result).toBe(expectedResult);\n"
                }
            ],
            "date": 1752917291502,
            "name": "Commit-0",
            "content": "import { OAuthCore } from '@zestic/oauth-core';\nimport { ExpoOAuthAdapter } from '../ExpoOAuthAdapter';\nimport { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../adapters';\nimport type { ExpoOAuthConfig, OAuthCallbackParams } from '../types';\n\n// Mock the adapters\njest.mock('../adapters/ExpoStorageAdapter');\njest.mock('../adapters/ExpoHttpAdapter');\njest.mock('../adapters/ExpoPKCEAdapter');\n\n// Mock OAuthCore\njest.mock('@zestic/oauth-core', () => ({\n  OAuthCore: jest.fn(),\n}));\n\nconst MockedOAuthCore = OAuthCore as jest.MockedClass<typeof OAuthCore>;\nconst MockedExpoStorageAdapter = ExpoStorageAdapter as jest.MockedClass<typeof ExpoStorageAdapter>;\nconst MockedExpoHttpAdapter = ExpoHttpAdapter as jest.MockedClass<typeof ExpoHttpAdapter>;\nconst MockedExpoPKCEAdapter = ExpoPKCEAdapter as jest.MockedClass<typeof ExpoPKCEAdapter>;\n\ndescribe('ExpoOAuthAdapter', () => {\n  let adapter: ExpoOAuthAdapter;\n  let mockOAuthCore: jest.Mocked<OAuthCore>;\n  let mockStorageAdapter: jest.Mocked<ExpoStorageAdapter>;\n  let mockHttpAdapter: jest.Mocked<ExpoHttpAdapter>;\n  let mockPKCEAdapter: jest.Mocked<ExpoPKCEAdapter>;\n\n  const mockConfig: ExpoOAuthConfig = {\n    clientId: 'test-client-id',\n    endpoints: {\n      authorization: 'https://auth.example.com/authorize',\n      token: 'https://auth.example.com/token',\n    },\n    redirectUri: 'myapp://oauth/callback',\n    scopes: ['read', 'write'],\n    scheme: 'myapp',\n    path: '/oauth/callback',\n  };\n\n  beforeEach(() => {\n    // Reset all mocks\n    jest.clearAllMocks();\n\n    // Create mock instances\n    mockOAuthCore = {\n      handleCallback: jest.fn(),\n    } as any;\n\n    mockStorageAdapter = {\n      setItem: jest.fn(),\n      getItem: jest.fn(),\n      removeItem: jest.fn(),\n      removeItems: jest.fn(),\n      clearOAuthStorage: jest.fn(),\n      storeTokens: jest.fn(),\n      getTokens: jest.fn(),\n      isTokenExpired: jest.fn(),\n    } as any;\n\n    mockHttpAdapter = {\n      post: jest.fn(),\n      get: jest.fn(),\n    } as any;\n\n    mockPKCEAdapter = {\n      generateCodeChallenge: jest.fn(),\n      generateState: jest.fn(),\n    } as any;\n\n    // Setup constructor mocks\n    MockedOAuthCore.mockImplementation(() => mockOAuthCore);\n    MockedExpoStorageAdapter.mockImplementation(() => mockStorageAdapter);\n    MockedExpoHttpAdapter.mockImplementation(() => mockHttpAdapter);\n    MockedExpoPKCEAdapter.mockImplementation(() => mockPKCEAdapter);\n\n    adapter = new ExpoOAuthAdapter(mockConfig);\n  });\n\n  describe('constructor', () => {\n    it('should initialize with correct adapters', () => {\n      expect(MockedExpoStorageAdapter).toHaveBeenCalledTimes(1);\n      expect(MockedExpoHttpAdapter).toHaveBeenCalledTimes(1);\n      expect(MockedExpoPKCEAdapter).toHaveBeenCalledTimes(1);\n    });\n\n    it('should initialize OAuthCore with config and adapters', () => {\n      expect(MockedOAuthCore).toHaveBeenCalledWith(\n        mockConfig,\n        {\n          storage: mockStorageAdapter,\n          http: mockHttpAdapter,\n          pkce: mockPKCEAdapter,\n        },\n        mockConfig.flows\n      );\n    });\n  });\n\n  describe('handleCallback', () => {\n    it('should convert params to URLSearchParams and call OAuthCore', async () => {\n      const callbackParams: OAuthCallbackParams = {\n        code: 'auth-code-123',\n        state: 'state-456',\n      };\n\n      const expectedResult = {\n        success: true,\n        tokens: { accessToken: 'token-123' },\n      };\n\n      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n\n      const result = await adapter.handleCallback(callbackParams);\n\n      expect(mockOAuthCore.handleCallback).toHaveBeenCalledWith(\n        expect.any(URLSearchParams)\n      );\n\n      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n      expect(urlParams.get('code')).toBe('auth-code-123');\n      expect(urlParams.get('state')).toBe('state-456');\n\n      expect(result).toBe(expectedResult);\n    });\n\n    it('should handle magic link callback params', async () => {\n      const callbackParams: OAuthCallbackParams = {\n        token: 'magic-link-token',\n        magic_link_token: 'magic-token-123',\n        flow: 'magic_link',\n      };\n\n      const expectedResult = {\n        success: true,\n        tokens: { accessToken: 'token-456' },\n      };\n\n      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n\n      const result = await adapter.handleCallback(callbackParams);\n\n      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n      expect(urlParams.get('token')).toBe('magic-link-token');\n      expect(urlParams.get('magic_link_token')).toBe('magic-token-123');\n      expect(urlParams.get('flow')).toBe('magic_link');\n\n      expect(result).toBe(expectedResult);\n    });\n\n    it('should handle error callback params', async () => {\n      const callbackParams: OAuthCallbackParams = {\n        error: 'access_denied',\n        error_description: 'User denied access',\n      };\n\n      const expectedResult = {\n        success: false,\n        error: 'access_denied',\n        message: 'User denied access',\n      };\n\n      mockOAuthCore.handleCallback.mockResolvedValue(expectedResult as any);\n\n      const result = await adapter.handleCallback(callbackParams);\n\n      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n      expect(urlParams.get('error')).toBe('access_denied');\n      expect(urlParams.get('error_description')).toBe('User denied access');\n\n      expect(result).toBe(expectedResult);\n    });\n\n    it('should filter out null and undefined values', async () => {\n      const callbackParams: OAuthCallbackParams = {\n        code: 'auth-code-123',\n        state: null,\n        error: undefined,\n      };\n\n      mockOAuthCore.handleCallback.mockResolvedValue({ success: true } as any);\n\n      await adapter.handleCallback(callbackParams);\n\n      const urlParams = mockOAuthCore.handleCallback.mock.calls[0][0] as URLSearchParams;\n      expect(urlParams.get('code')).toBe('auth-code-123');\n      expect(urlParams.has('state')).toBe(false);\n      expect(urlParams.has('error')).toBe(false);\n    });\n  });\n\n  describe('generatePKCEParams', () => {\n    it('should generate and store PKCE parameters', async () => {\n      const mockChallenge = {\n        codeChallenge: 'challenge-123',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'verifier-456',\n      };\n      const mockState = 'state-789';\n\n      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n      mockStorageAdapter.setItem.mockResolvedValue();\n\n      const result = await adapter.generatePKCEParams();\n\n      expect(mockPKCEAdapter.generateCodeChallenge).toHaveBeenCalledTimes(1);\n      expect(mockPKCEAdapter.generateState).toHaveBeenCalledTimes(1);\n\n      expect(mockStorageAdapter.setItem).toHaveBeenCalledWith('oauth_code_verifier', 'verifier-456');\n      expect(mockStorageAdapter.setItem).toHaveBeenCalledWith('oauth_state', 'state-789');\n\n      expect(result).toEqual({\n        codeChallenge: 'challenge-123',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'verifier-456',\n        state: 'state-789',\n      });\n    });\n\n    it('should handle PKCE generation errors', async () => {\n      mockPKCEAdapter.generateCodeChallenge.mockRejectedValue(new Error('PKCE generation failed'));\n\n      await expect(adapter.generatePKCEParams()).rejects.toThrow('PKCE generation failed');\n    });\n\n    it('should handle storage errors', async () => {\n      const mockChallenge = {\n        codeChallenge: 'challenge-123',\n        codeChallengeMethod: 'S256',\n        codeVerifier: 'verifier-456',\n      };\n      const mockState = 'state-789';\n\n      mockPKCEAdapter.generateCodeChallenge.mockResolvedValue(mockChallenge);\n      mockPKCEAdapter.generateState.mockResolvedValue(mockState);\n      mockStorageAdapter.setItem.mockRejectedValue(new Error('Storage failed'));\n\n      await expect(adapter.generatePKCEParams()).rejects.toThrow('Storage failed');\n    });\n  });\n\n  describe('generateAuthorizationUrl', () => {\n    it('should delegate to OAuthCore and return authorization URL', async () => {\n      const mockResult = {\n        url: 'https://auth.example.com/oauth/authorize?client_id=test-client&response_type=code&state=test-state',\n        state: 'test-state-789',\n      };\n\n      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n\n      const result = await adapter.generateAuthorizationUrl();\n\n      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith(undefined);\n      expect(result).toEqual(mockResult);\n    });\n\n    it('should pass additional parameters to OAuthCore', async () => {\n      const additionalParams = {\n        audience: 'https://api.example.com',\n        prompt: 'consent',\n      };\n\n      const mockResult = {\n        url: 'https://auth.example.com/oauth/authorize?client_id=test-client&audience=https://api.example.com',\n        state: 'test-state-789',\n      };\n\n      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n\n      const result = await adapter.generateAuthorizationUrl(additionalParams);\n\n      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith(additionalParams);\n      expect(result).toEqual(mockResult);\n    });\n\n    it('should handle OAuthCore errors', async () => {\n      mockOAuthCore.generateAuthorizationUrl.mockRejectedValue(new Error('URL generation failed'));\n\n      await expect(adapter.generateAuthorizationUrl()).rejects.toThrow('URL generation failed');\n    });\n\n    it('should handle empty additional parameters', async () => {\n      const mockResult = {\n        url: 'https://auth.example.com/oauth/authorize?client_id=test-client',\n        state: 'test-state-789',\n      };\n\n      mockOAuthCore.generateAuthorizationUrl.mockResolvedValue(mockResult);\n\n      const result = await adapter.generateAuthorizationUrl({});\n\n      expect(mockOAuthCore.generateAuthorizationUrl).toHaveBeenCalledWith({});\n      expect(result).toEqual(mockResult);\n    });\n  });\n\n  describe('isAuthenticated', () => {\n    it('should return true when tokens exist and are not expired', async () => {\n      mockStorageAdapter.getTokens.mockResolvedValue({\n        accessToken: 'token-123',\n        refreshToken: 'refresh-456',\n        expiresAt: Date.now() + 3600000,\n      });\n      mockStorageAdapter.isTokenExpired.mockResolvedValue(false);\n\n      const result = await adapter.isAuthenticated();\n\n      expect(result).toBe(true);\n    });\n\n    it('should return false when no access token exists', async () => {\n      mockStorageAdapter.getTokens.mockResolvedValue({\n        accessToken: null,\n        refreshToken: null,\n        expiresAt: null,\n      });\n\n      const result = await adapter.isAuthenticated();\n\n      expect(result).toBe(false);\n    });\n\n    it('should return false when token is expired', async () => {\n      mockStorageAdapter.getTokens.mockResolvedValue({\n        accessToken: 'token-123',\n        refreshToken: 'refresh-456',\n        expiresAt: Date.now() - 1000,\n      });\n      mockStorageAdapter.isTokenExpired.mockResolvedValue(true);\n\n      const result = await adapter.isAuthenticated();\n\n      expect(result).toBe(false);\n    });\n  });\n\n  describe('getAccessToken', () => {\n    it('should return access token when valid', async () => {\n      mockStorageAdapter.getTokens.mockResolvedValue({\n        accessToken: 'token-123',\n        refreshToken: 'refresh-456',\n        expiresAt: Date.now() + 3600000,\n      });\n      mockStorageAdapter.isTokenExpired.mockResolvedValue(false);\n\n      const result = await adapter.getAccessToken();\n\n      expect(result).toBe('token-123');\n    });\n\n    it('should logout and return null when token is expired', async () => {\n      mockStorageAdapter.getTokens.mockResolvedValue({\n        accessToken: 'token-123',\n        refreshToken: 'refresh-456',\n        expiresAt: Date.now() - 1000,\n      });\n      mockStorageAdapter.isTokenExpired.mockResolvedValue(true);\n      mockStorageAdapter.clearOAuthStorage.mockResolvedValue();\n\n      const result = await adapter.getAccessToken();\n\n      expect(mockStorageAdapter.clearOAuthStorage).toHaveBeenCalledTimes(1);\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('logout', () => {\n    it('should clear OAuth storage', async () => {\n      mockStorageAdapter.clearOAuthStorage.mockResolvedValue();\n\n      await adapter.logout();\n\n      expect(mockStorageAdapter.clearOAuthStorage).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle storage errors during logout', async () => {\n      mockStorageAdapter.clearOAuthStorage.mockRejectedValue(new Error('Clear storage failed'));\n\n      await expect(adapter.logout()).rejects.toThrow('Clear storage failed');\n    });\n  });\n});\n"
        }
    ]
}