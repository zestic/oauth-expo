{
    "sourceFile": "src/hooks/useOAuthCallback.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1752839224100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752839241637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,45 +37,26 @@\n     try {\n       setStatus('processing');\n       setMessage('Processing OAuth callback...');\n \n-      // Check for error parameters first\n-      if (params.error) {\n-        throw new OAuthError(\n-          params.error_description || params.error,\n-          params.error\n-        );\n-      }\n+      // Create OAuthCore instance with Expo adapters\n+      const oauthCore = new OAuthCore(config, adapters, config.flows);\n \n-      let result: OAuthResult;\n+      // Convert params to URLSearchParams for OAuthCore\n+      const urlParams = new URLSearchParams();\n+      Object.entries(params).forEach(([key, value]) => {\n+        if (value) urlParams.set(key, String(value));\n+      });\n \n-      // Determine flow type and handle accordingly\n-      if (params.flow === 'registration' && (params.token || params.magic_link_token)) {\n-        result = await handleRegistrationCallback(params, config, adapters);\n-      } else if (params.flow === 'login' && (params.token || params.magic_link_token)) {\n-        result = await handleMagicLinkCallback(params, config, adapters);\n-      } else if (params.magic_link_token || params.token) {\n-        // Fallback to magic link flow\n-        result = await handleMagicLinkCallback(params, config, adapters);\n-      } else if (params.code) {\n-        // OAuth2 authorization code flow\n-        result = await handleAuthorizationCodeCallback(params, config, adapters);\n-      } else {\n-        throw new OAuthError(\n-          'No valid OAuth parameters found in callback',\n-          OAUTH_ERROR_CODES.INVALID_GRANT\n-        );\n-      }\n+      // Use OAuthCore to handle the callback with automatic flow detection\n+      const result = await oauthCore.handleCallback(urlParams);\n \n       if (result.success) {\n         setStatus('success');\n         setMessage('OAuth authentication successful!');\n         options?.onSuccess?.(result);\n       } else {\n-        throw new OAuthError(\n-          result.error || 'OAuth authentication failed',\n-          OAUTH_ERROR_CODES.TOKEN_EXCHANGE_FAILED\n-        );\n+        throw new Error(result.error || 'OAuth authentication failed');\n       }\n     } catch (error) {\n       setStatus('error');\n       const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n"
                },
                {
                    "date": 1752839260792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,120 +83,5 @@\n     retry,\n   };\n }\n \n-/**\n- * Handle OAuth2 authorization code flow callback\n- */\n-async function handleAuthorizationCodeCallback(\n-  params: OAuthCallbackParams,\n-  config: ExpoOAuthConfig,\n-  adapters: OAuthAdapters\n-): Promise<OAuthResult> {\n-  if (!params.code) {\n-    throw new OAuthError('Missing authorization code', OAUTH_ERROR_CODES.INVALID_GRANT);\n-  }\n \n-  // Validate state if present\n-  if (params.state) {\n-    const storedState = await adapters.storage.getItem('oauth_state');\n-    if (!storedState || storedState !== params.state) {\n-      throw new OAuthError('Invalid state parameter', OAUTH_ERROR_CODES.INVALID_STATE);\n-    }\n-  }\n-\n-  // Get stored code verifier\n-  const codeVerifier = await adapters.storage.getItem('oauth_code_verifier');\n-  if (!codeVerifier) {\n-    throw new OAuthError('Missing PKCE code verifier', OAUTH_ERROR_CODES.MISSING_PKCE);\n-  }\n-\n-  // Exchange code for tokens\n-  const tokenResponse = await adapters.http.exchangeCodeForTokens({\n-    tokenEndpoint: config.endpoints.token,\n-    clientId: config.clientId,\n-    code: params.code,\n-    redirectUri: config.redirectUri,\n-    codeVerifier,\n-  });\n-\n-  // Store tokens\n-  if (adapters.storage instanceof ExpoStorageAdapter) {\n-    await adapters.storage.storeTokens({\n-      accessToken: tokenResponse.access_token,\n-      refreshToken: tokenResponse.refresh_token,\n-      expiresIn: tokenResponse.expires_in,\n-    });\n-  }\n-\n-  // Clean up temporary storage\n-  await adapters.storage.removeItems(['oauth_state', 'oauth_code_verifier']);\n-\n-  return {\n-    success: true,\n-    accessToken: tokenResponse.access_token,\n-    refreshToken: tokenResponse.refresh_token,\n-    expiresIn: tokenResponse.expires_in,\n-  };\n-}\n-\n-/**\n- * Handle magic link callback (both login and registration)\n- */\n-async function handleMagicLinkCallback(\n-  params: OAuthCallbackParams,\n-  config: ExpoOAuthConfig,\n-  adapters: OAuthAdapters\n-): Promise<OAuthResult> {\n-  const token = params.token || params.magic_link_token;\n-  if (!token) {\n-    throw new OAuthError('Missing magic link token', OAUTH_ERROR_CODES.INVALID_GRANT);\n-  }\n-\n-  // Get stored PKCE parameters\n-  const codeVerifier = await adapters.storage.getItem('oauth_code_verifier');\n-  const storedState = await adapters.storage.getItem('oauth_state');\n-\n-  if (!codeVerifier || !storedState) {\n-    throw new OAuthError('Missing PKCE parameters', OAUTH_ERROR_CODES.MISSING_PKCE);\n-  }\n-\n-  // Exchange magic link token for OAuth tokens\n-  const tokenResponse = await adapters.http.exchangeMagicLinkToken({\n-    tokenEndpoint: config.endpoints.token,\n-    clientId: config.clientId,\n-    token,\n-    codeVerifier,\n-    state: storedState,\n-  });\n-\n-  // Store tokens\n-  if (adapters.storage instanceof ExpoStorageAdapter) {\n-    await adapters.storage.storeTokens({\n-      accessToken: tokenResponse.access_token,\n-      refreshToken: tokenResponse.refresh_token,\n-      expiresIn: tokenResponse.expires_in,\n-    });\n-  }\n-\n-  // Clean up temporary storage\n-  await adapters.storage.removeItems(['oauth_state', 'oauth_code_verifier']);\n-\n-  return {\n-    success: true,\n-    accessToken: tokenResponse.access_token,\n-    refreshToken: tokenResponse.refresh_token,\n-    expiresIn: tokenResponse.expires_in,\n-  };\n-}\n-\n-/**\n- * Handle registration callback (uses magic link flow)\n- */\n-async function handleRegistrationCallback(\n-  params: OAuthCallbackParams,\n-  config: ExpoOAuthConfig,\n-  adapters: OAuthAdapters\n-): Promise<OAuthResult> {\n-  // Registration uses the same flow as magic link login\n-  return handleMagicLinkCallback(params, config, adapters);\n-}\n"
                },
                {
                    "date": 1752853148792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,13 @@\n import { useState, useCallback, useEffect } from 'react';\n-import { OAuthCore } from '@zestic/oauth-core';\n+import { ExpoOAuthAdapter } from '../ExpoOAuthAdapter';\n import type {\n   OAuthCallbackParams,\n   OAuthStatus,\n   UseOAuthCallbackResult,\n   ExpoOAuthConfig,\n   OAuthResult,\n-  OAuthAdapters\n } from '../types';\n-import { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../adapters';\n \n /**\n  * React hook for handling OAuth callback processing\n  * Manages the OAuth callback flow state and provides handlers\n"
                },
                {
                    "date": 1752853174897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,35 +23,22 @@\n ): UseOAuthCallbackResult {\n   const [status, setStatus] = useState<OAuthStatus>('processing');\n   const [message, setMessage] = useState('Processing OAuth callback...');\n \n-  // Create adapters\n-  const adapters: OAuthAdapters = {\n-    storage: new ExpoStorageAdapter(),\n-    http: new ExpoHttpAdapter(),\n-    pkce: new ExpoPKCEAdapter(),\n-  };\n-\n   const handleCallback = useCallback(async (): Promise<void> => {\n     try {\n       setStatus('processing');\n       setMessage('Processing OAuth callback...');\n \n-      // Create OAuthCore instance with Expo adapters\n-      const oauthCore = new OAuthCore(config, adapters, config.flows);\n+      // Create ExpoOAuthAdapter instance\n+      const adapter = new ExpoOAuthAdapter(config);\n \n-      // Convert params to URLSearchParams for OAuthCore\n-      const urlParams = new URLSearchParams();\n-      Object.entries(params).forEach(([key, value]) => {\n-        if (value) urlParams.set(key, String(value));\n-      });\n+      // Use adapter to handle the callback\n+      const result = await adapter.handleCallback(params);\n \n-      // Use OAuthCore to handle the callback with automatic flow detection\n-      const result = await oauthCore.handleCallback(urlParams);\n-\n       if (result.success) {\n         setStatus('success');\n-        setMessage('OAuth authentication successful!');\n+        setMessage('Authentication successful');\n         options?.onSuccess?.(result);\n       } else {\n         throw new Error(result.error || 'OAuth authentication failed');\n       }\n"
                }
            ],
            "date": 1752839224100,
            "name": "Commit-0",
            "content": "import { useState, useCallback, useEffect } from 'react';\nimport { OAuthCore } from '@zestic/oauth-core';\nimport type {\n  OAuthCallbackParams,\n  OAuthStatus,\n  UseOAuthCallbackResult,\n  ExpoOAuthConfig,\n  OAuthResult,\n  OAuthAdapters\n} from '../types';\nimport { ExpoStorageAdapter, ExpoHttpAdapter, ExpoPKCEAdapter } from '../adapters';\n\n/**\n * React hook for handling OAuth callback processing\n * Manages the OAuth callback flow state and provides handlers\n */\nexport function useOAuthCallback(\n  params: OAuthCallbackParams,\n  config: ExpoOAuthConfig,\n  options?: {\n    onSuccess?: (result: OAuthResult) => void;\n    onError?: (error: Error) => void;\n    autoStart?: boolean;\n  }\n): UseOAuthCallbackResult {\n  const [status, setStatus] = useState<OAuthStatus>('processing');\n  const [message, setMessage] = useState('Processing OAuth callback...');\n\n  // Create adapters\n  const adapters: OAuthAdapters = {\n    storage: new ExpoStorageAdapter(),\n    http: new ExpoHttpAdapter(),\n    pkce: new ExpoPKCEAdapter(),\n  };\n\n  const handleCallback = useCallback(async (): Promise<void> => {\n    try {\n      setStatus('processing');\n      setMessage('Processing OAuth callback...');\n\n      // Check for error parameters first\n      if (params.error) {\n        throw new OAuthError(\n          params.error_description || params.error,\n          params.error\n        );\n      }\n\n      let result: OAuthResult;\n\n      // Determine flow type and handle accordingly\n      if (params.flow === 'registration' && (params.token || params.magic_link_token)) {\n        result = await handleRegistrationCallback(params, config, adapters);\n      } else if (params.flow === 'login' && (params.token || params.magic_link_token)) {\n        result = await handleMagicLinkCallback(params, config, adapters);\n      } else if (params.magic_link_token || params.token) {\n        // Fallback to magic link flow\n        result = await handleMagicLinkCallback(params, config, adapters);\n      } else if (params.code) {\n        // OAuth2 authorization code flow\n        result = await handleAuthorizationCodeCallback(params, config, adapters);\n      } else {\n        throw new OAuthError(\n          'No valid OAuth parameters found in callback',\n          OAUTH_ERROR_CODES.INVALID_GRANT\n        );\n      }\n\n      if (result.success) {\n        setStatus('success');\n        setMessage('OAuth authentication successful!');\n        options?.onSuccess?.(result);\n      } else {\n        throw new OAuthError(\n          result.error || 'OAuth authentication failed',\n          OAUTH_ERROR_CODES.TOKEN_EXCHANGE_FAILED\n        );\n      }\n    } catch (error) {\n      setStatus('error');\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n      setMessage(errorMessage);\n      options?.onError?.(error instanceof Error ? error : new Error(errorMessage));\n    }\n  }, [params, config, options]);\n\n  const retry = useCallback(() => {\n    handleCallback();\n  }, [handleCallback]);\n\n  // Auto-start if enabled (default: true)\n  useEffect(() => {\n    if (options?.autoStart !== false) {\n      handleCallback();\n    }\n  }, [handleCallback, options?.autoStart]);\n\n  return {\n    status,\n    message,\n    handleCallback,\n    retry,\n  };\n}\n\n/**\n * Handle OAuth2 authorization code flow callback\n */\nasync function handleAuthorizationCodeCallback(\n  params: OAuthCallbackParams,\n  config: ExpoOAuthConfig,\n  adapters: OAuthAdapters\n): Promise<OAuthResult> {\n  if (!params.code) {\n    throw new OAuthError('Missing authorization code', OAUTH_ERROR_CODES.INVALID_GRANT);\n  }\n\n  // Validate state if present\n  if (params.state) {\n    const storedState = await adapters.storage.getItem('oauth_state');\n    if (!storedState || storedState !== params.state) {\n      throw new OAuthError('Invalid state parameter', OAUTH_ERROR_CODES.INVALID_STATE);\n    }\n  }\n\n  // Get stored code verifier\n  const codeVerifier = await adapters.storage.getItem('oauth_code_verifier');\n  if (!codeVerifier) {\n    throw new OAuthError('Missing PKCE code verifier', OAUTH_ERROR_CODES.MISSING_PKCE);\n  }\n\n  // Exchange code for tokens\n  const tokenResponse = await adapters.http.exchangeCodeForTokens({\n    tokenEndpoint: config.endpoints.token,\n    clientId: config.clientId,\n    code: params.code,\n    redirectUri: config.redirectUri,\n    codeVerifier,\n  });\n\n  // Store tokens\n  if (adapters.storage instanceof ExpoStorageAdapter) {\n    await adapters.storage.storeTokens({\n      accessToken: tokenResponse.access_token,\n      refreshToken: tokenResponse.refresh_token,\n      expiresIn: tokenResponse.expires_in,\n    });\n  }\n\n  // Clean up temporary storage\n  await adapters.storage.removeItems(['oauth_state', 'oauth_code_verifier']);\n\n  return {\n    success: true,\n    accessToken: tokenResponse.access_token,\n    refreshToken: tokenResponse.refresh_token,\n    expiresIn: tokenResponse.expires_in,\n  };\n}\n\n/**\n * Handle magic link callback (both login and registration)\n */\nasync function handleMagicLinkCallback(\n  params: OAuthCallbackParams,\n  config: ExpoOAuthConfig,\n  adapters: OAuthAdapters\n): Promise<OAuthResult> {\n  const token = params.token || params.magic_link_token;\n  if (!token) {\n    throw new OAuthError('Missing magic link token', OAUTH_ERROR_CODES.INVALID_GRANT);\n  }\n\n  // Get stored PKCE parameters\n  const codeVerifier = await adapters.storage.getItem('oauth_code_verifier');\n  const storedState = await adapters.storage.getItem('oauth_state');\n\n  if (!codeVerifier || !storedState) {\n    throw new OAuthError('Missing PKCE parameters', OAUTH_ERROR_CODES.MISSING_PKCE);\n  }\n\n  // Exchange magic link token for OAuth tokens\n  const tokenResponse = await adapters.http.exchangeMagicLinkToken({\n    tokenEndpoint: config.endpoints.token,\n    clientId: config.clientId,\n    token,\n    codeVerifier,\n    state: storedState,\n  });\n\n  // Store tokens\n  if (adapters.storage instanceof ExpoStorageAdapter) {\n    await adapters.storage.storeTokens({\n      accessToken: tokenResponse.access_token,\n      refreshToken: tokenResponse.refresh_token,\n      expiresIn: tokenResponse.expires_in,\n    });\n  }\n\n  // Clean up temporary storage\n  await adapters.storage.removeItems(['oauth_state', 'oauth_code_verifier']);\n\n  return {\n    success: true,\n    accessToken: tokenResponse.access_token,\n    refreshToken: tokenResponse.refresh_token,\n    expiresIn: tokenResponse.expires_in,\n  };\n}\n\n/**\n * Handle registration callback (uses magic link flow)\n */\nasync function handleRegistrationCallback(\n  params: OAuthCallbackParams,\n  config: ExpoOAuthConfig,\n  adapters: OAuthAdapters\n): Promise<OAuthResult> {\n  // Registration uses the same flow as magic link login\n  return handleMagicLinkCallback(params, config, adapters);\n}\n"
        }
    ]
}